<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Pansheng`s Blog</title>
  
  <subtitle>不积跬步，无以至千里！</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://wangpansheng.github.io/"/>
  <updated>2018-01-31T12:28:58.927Z</updated>
  <id>https://wangpansheng.github.io/</id>
  
  <author>
    <name>Pansheng</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>初识Koa</title>
    <link href="https://wangpansheng.github.io/2018/01/31/%E5%88%9D%E8%AF%86Koa/"/>
    <id>https://wangpansheng.github.io/2018/01/31/初识Koa/</id>
    <published>2018-01-31T09:39:36.000Z</published>
    <updated>2018-01-31T12:28:58.927Z</updated>
    
    <content type="html"><![CDATA[<p>Koa是Express原版团队开发的一个代替express的新一代node框架。<br><a id="more"></a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Koa是Express原版团队开发的一个代替express的新一代node框架。&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>手动一步一步搭建ss</title>
    <link href="https://wangpansheng.github.io/2018/01/31/%E6%89%8B%E5%8A%A8%E4%B8%80%E6%AD%A5%E4%B8%80%E6%AD%A5%E6%90%AD%E5%BB%BAss/"/>
    <id>https://wangpansheng.github.io/2018/01/31/手动一步一步搭建ss/</id>
    <published>2018-01-31T08:02:12.000Z</published>
    <updated>2018-01-31T12:42:33.003Z</updated>
    
    <content type="html"><![CDATA[<h1 id="动手安装ss-教程"><a href="#动手安装ss-教程" class="headerlink" title="动手安装ss,教程"></a>动手安装ss,教程</h1><h2 id="安装具体步骤"><a href="#安装具体步骤" class="headerlink" title="安装具体步骤"></a>安装具体步骤</h2><p> 我用的是Ubuntu系统，安装步骤非常简单，一步一步执行下面的命令就好</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">&lt;!-- 如果服务器没有安装git，需要执行这一步 --&gt;</span><br><span class="line">sudo apt-get install git</span><br><span class="line">sudo apt-get install python-pip</span><br><span class="line">pip install git+https://github.com/shadowsocks/shadowsocks.git@master</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="具体使用"><a href="#具体使用" class="headerlink" title="具体使用"></a>具体使用</h2><h4 id="直接使用"><a href="#直接使用" class="headerlink" title="直接使用"></a>直接使用</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssserver -c /etc/shadowsocks.json</span><br></pre></td></tr></table></figure><h4 id="后台使用"><a href="#后台使用" class="headerlink" title="后台使用"></a>后台使用</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ssserver -c /etc/shadowsocks.json -d start</span><br><span class="line">ssserver -c /etc/shadowsocks.json -d stop</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;动手安装ss-教程&quot;&gt;&lt;a href=&quot;#动手安装ss-教程&quot; class=&quot;headerlink&quot; title=&quot;动手安装ss,教程&quot;&gt;&lt;/a&gt;动手安装ss,教程&lt;/h1&gt;&lt;h2 id=&quot;安装具体步骤&quot;&gt;&lt;a href=&quot;#安装具体步骤&quot; class=&quot;headerlink&quot; title=&quot;安装具体步骤&quot;&gt;&lt;/a&gt;安装具体步骤&lt;/h2&gt;&lt;p&gt; 我用的是Ubuntu系统，安装步骤非常简单，一步一步执行下面的命令就好&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;sudo apt-get update&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;lt;!-- 如果服务器没有安装git，需要执行这一步 --&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;sudo apt-get install git&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;sudo apt-get install python-pip&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;pip install git+https://github.com/shadowsocks/shadowsocks.git@master&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>css变形</title>
    <link href="https://wangpansheng.github.io/2017/07/11/css%E5%8F%98%E5%BD%A2/"/>
    <id>https://wangpansheng.github.io/2017/07/11/css变形/</id>
    <published>2017-07-11T01:23:13.000Z</published>
    <updated>2018-01-31T12:35:05.792Z</updated>
    
    <content type="html"><![CDATA[<h1>css变形</h1><blockquote><p>  我们可以借助css3实现图片元素的倾斜、缩放、移动、以及翻转效果。</p></blockquote><h2 id="1-tranfrom属性语法"><a href="#1-tranfrom属性语法" class="headerlink" title="1.  tranfrom属性语法"></a>1.  tranfrom属性语法</h2><blockquote><p>  tranfrom属性让元素在一个坐标系统中变形，包含一系列变形函数，可以移动、旋转和缩放元素。</p></blockquote><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">transfrom: none | &lt;transfrom-function&gt;</span><br></pre></td></tr></table></figure><ul><li>默认值为:none,表示不对元素进行变形;</li><li>也可以指定一个或者多个变形函数，以空格分开。如：rotate、scale、trasnslate;</li></ul><h2 id="2-变形函数介绍"><a href="#2-变形函数介绍" class="headerlink" title="2.  变形函数介绍"></a>2.  变形函数介绍</h2><a id="more"></a><blockquote><p>  所有的2D变形函数可以应用于3D变形规范中。</p></blockquote><pre><code>函数 | 功能描述----|-------translate() | 移动元素，可以根据X轴和Y轴坐标重新定位自己的位置，有tranlateX(),translateY()scale() | 缩小或者方法元素，可以使元素尺寸发生变化，有scaleX()和scaleY()rotate() | 旋转元素skew() | 让元素倾斜，在此基础上有两个扩展函数，skewX()和skewY()matrix()|定义矩阵变形，基于X轴和Y轴坐标重新定位元素位置</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h1&gt;css变形&lt;/h1&gt;

&lt;blockquote&gt;
&lt;p&gt;  我们可以借助css3实现图片元素的倾斜、缩放、移动、以及翻转效果。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;1-tranfrom属性语法&quot;&gt;&lt;a href=&quot;#1-tranfrom属性语法&quot; class=&quot;headerlink&quot; title=&quot;1.  tranfrom属性语法&quot;&gt;&lt;/a&gt;1.  tranfrom属性语法&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;  tranfrom属性让元素在一个坐标系统中变形，包含一系列变形函数，可以移动、旋转和缩放元素。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;transfrom: none | &amp;lt;transfrom-function&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;默认值为:none,表示不对元素进行变形;&lt;/li&gt;
&lt;li&gt;也可以指定一个或者多个变形函数，以空格分开。如：rotate、scale、trasnslate;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;2-变形函数介绍&quot;&gt;&lt;a href=&quot;#2-变形函数介绍&quot; class=&quot;headerlink&quot; title=&quot;2.  变形函数介绍&quot;&gt;&lt;/a&gt;2.  变形函数介绍&lt;/h2&gt;
    
    </summary>
    
    
      <category term="css3" scheme="https://wangpansheng.github.io/tags/css3/"/>
    
  </entry>
  
  <entry>
    <title>前后端渲染的对比</title>
    <link href="https://wangpansheng.github.io/2017/05/14/%E5%89%8D%E5%90%8E%E7%AB%AF%E6%B8%B2%E6%9F%93%E7%9A%84%E5%AF%B9%E6%AF%94/"/>
    <id>https://wangpansheng.github.io/2017/05/14/前后端渲染的对比/</id>
    <published>2017-05-14T11:01:13.000Z</published>
    <updated>2018-01-31T12:39:09.846Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>  服务端渲染是通过后端模板引擎编译成html,css,js,然后回传给前端来进行显示；而前端渲染则是将整个生成逻辑代码全部回传前端，再由客户端生成用户界面。</p></blockquote><h2 id="为什么会有服务端渲染与客户端渲染"><a href="#为什么会有服务端渲染与客户端渲染" class="headerlink" title="为什么会有服务端渲染与客户端渲染"></a>为什么会有服务端渲染与客户端渲染</h2><p>早期，我们每一个页面都是直接由html，css，js实现的，每一个页面彼此之间相当于是独立的，当我们的网站应用足够大的时候，每当我们需要修改网站的内容时，我们需要更改很多的代码，非常麻烦。</p><p>那么后来，我们聪明的程序员就想到了，使用代码生成代码，就是后端的模板引擎，人们开始广泛使用模板代替手写html，大大减少的前端的工作量。通过代码生成代码，其实就是编译，基于html等基础语言，做出了更高层次的抽象封装，增加了易用性。</p><p>后来h5,c3的崛起，再加上客户端硬件性能的提升，我们开始通过前端模板引擎，来在客户端渲染页面。</p><p>对待模板，angular，vue，react的态度都不一样。</p><a id="more"></a><p><strong>前后端真正解耦，前端专注于UI视图,后台专注于数据处理，通过设计好的api交互，这是未来的趋势。</strong></p><h2 id="从-后端渲染-到-前端渲染-，有什么变化"><a href="#从-后端渲染-到-前端渲染-，有什么变化" class="headerlink" title="从 后端渲染 到 前端渲染 ，有什么变化"></a>从 后端渲染 到 前端渲染 ，有什么变化</h2><ul><li>计算任务的变化</li></ul><blockquote><p>  原来由后端执行的渲染任务，现在放在了前端来做，降低了多用户同时访问时服务端的压力，然后端专注做后端的事情，由于客户端硬件的发展，前端处理起来没有什么问题。</p></blockquote><ul><li>放弃前端权限</li></ul><blockquote><p>  将整个页面逻辑，交给客户端以后，会出现劫持的情况，比如某些运营商劫持之后，投放广告。俗话说的好<strong>一切在前端谈安全都是耍流氓</strong>，后端不能轻信前端发来的数据，一切数据都需要过滤与验证，最好使用ssl，屏蔽XSS。</p></blockquote><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p><strong>总之一句话，后端渲染针对seo比较友好，前端渲染，可以减轻服务端的压力，提升服务器的性能，而且可以实现前后端分离！</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;  服务端渲染是通过后端模板引擎编译成html,css,js,然后回传给前端来进行显示；而前端渲染则是将整个生成逻辑代码全部回传前端，再由客户端生成用户界面。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;为什么会有服务端渲染与客户端渲染&quot;&gt;&lt;a href=&quot;#为什么会有服务端渲染与客户端渲染&quot; class=&quot;headerlink&quot; title=&quot;为什么会有服务端渲染与客户端渲染&quot;&gt;&lt;/a&gt;为什么会有服务端渲染与客户端渲染&lt;/h2&gt;&lt;p&gt;早期，我们每一个页面都是直接由html，css，js实现的，每一个页面彼此之间相当于是独立的，当我们的网站应用足够大的时候，每当我们需要修改网站的内容时，我们需要更改很多的代码，非常麻烦。&lt;/p&gt;
&lt;p&gt;那么后来，我们聪明的程序员就想到了，使用代码生成代码，就是后端的模板引擎，人们开始广泛使用模板代替手写html，大大减少的前端的工作量。通过代码生成代码，其实就是编译，基于html等基础语言，做出了更高层次的抽象封装，增加了易用性。&lt;/p&gt;
&lt;p&gt;后来h5,c3的崛起，再加上客户端硬件性能的提升，我们开始通过前端模板引擎，来在客户端渲染页面。&lt;/p&gt;
&lt;p&gt;对待模板，angular，vue，react的态度都不一样。&lt;/p&gt;
    
    </summary>
    
    
      <category term="服务端渲染" scheme="https://wangpansheng.github.io/tags/%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%B8%B2%E6%9F%93/"/>
    
  </entry>
  
  <entry>
    <title>ubuntu常见问题处理</title>
    <link href="https://wangpansheng.github.io/2017/04/02/ubuntu%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/"/>
    <id>https://wangpansheng.github.io/2017/04/02/ubuntu常见问题/</id>
    <published>2017-04-02T09:46:19.000Z</published>
    <updated>2018-01-31T12:42:33.003Z</updated>
    
    <content type="html"><![CDATA[<h2 id="常见问题处理"><a href="#常见问题处理" class="headerlink" title="常见问题处理"></a>常见问题处理</h2><h3 id="1-win10和ubuntu双系统时，硬盘无法加载问题"><a href="#1-win10和ubuntu双系统时，硬盘无法加载问题" class="headerlink" title="1.  win10和ubuntu双系统时，硬盘无法加载问题"></a>1.  win10和ubuntu双系统时，硬盘无法加载问题</h3><ul><li><p>需要依赖于ntfs-3g，如果没有需要先安装这个</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install ntfs-3g</span><br></pre></td></tr></table></figure></li><li><p>然后只用ntfsfix修复，即可</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo ntfsfix /绝对路径</span><br></pre></td></tr></table></figure></li></ul><a id="more"></a><h2 id="常用软件推荐"><a href="#常用软件推荐" class="headerlink" title="常用软件推荐"></a>常用软件推荐</h2><h3 id="1-图片处理-GIMP"><a href="#1-图片处理-GIMP" class="headerlink" title="1.   图片处理:GIMP"></a>1.   图片处理:GIMP</h3><ul><li>对于非专业性的图片处理，该款APP已经十分足够了，功能也挺丰富、强大的。</li></ul><h3 id="2-视频播放：VLC"><a href="#2-视频播放：VLC" class="headerlink" title="2.  视频播放：VLC"></a>2.  视频播放：VLC</h3><ul><li>能够播放rmvb、mp4、avi等多种格式的视频文件，支持快速播放等功能。</li><li>安装<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ sudo add-apt-repository ppa:videolan/stable-daily</span><br><span class="line">$ sudo apt-get update</span><br><span class="line">$ sudo apt-get install vlc</span><br></pre></td></tr></table></figure></li></ul><h3 id="3-启动栏：Docky"><a href="#3-启动栏：Docky" class="headerlink" title="3.  启动栏：Docky"></a>3.  启动栏：Docky</h3><ul><li>ndicator-sysmonitor 这是一款能够实时查看当前系统的CPU、内存、网络、IP等信息</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;常见问题处理&quot;&gt;&lt;a href=&quot;#常见问题处理&quot; class=&quot;headerlink&quot; title=&quot;常见问题处理&quot;&gt;&lt;/a&gt;常见问题处理&lt;/h2&gt;&lt;h3 id=&quot;1-win10和ubuntu双系统时，硬盘无法加载问题&quot;&gt;&lt;a href=&quot;#1-win10和ubuntu双系统时，硬盘无法加载问题&quot; class=&quot;headerlink&quot; title=&quot;1.  win10和ubuntu双系统时，硬盘无法加载问题&quot;&gt;&lt;/a&gt;1.  win10和ubuntu双系统时，硬盘无法加载问题&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;需要依赖于ntfs-3g，如果没有需要先安装这个&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;sudo apt-get install ntfs-3g&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;然后只用ntfsfix修复，即可&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;sudo ntfsfix /绝对路径&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="linux" scheme="https://wangpansheng.github.io/tags/linux/"/>
    
      <category term="ubuntu" scheme="https://wangpansheng.github.io/tags/ubuntu/"/>
    
  </entry>
  
  <entry>
    <title>ubuntu常用软件部署</title>
    <link href="https://wangpansheng.github.io/2017/04/02/ubuntu%E5%B8%B8%E7%94%A8%E8%BD%AF%E4%BB%B6%E9%83%A8%E7%BD%B2/"/>
    <id>https://wangpansheng.github.io/2017/04/02/ubuntu常用软件部署/</id>
    <published>2017-04-02T09:46:19.000Z</published>
    <updated>2018-01-31T12:39:09.828Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ubuntu中快速安装nodejs"><a href="#ubuntu中快速安装nodejs" class="headerlink" title="ubuntu中快速安装nodejs"></a>ubuntu中快速安装nodejs</h1><h2 id="1-我们可以直接通过apt-get安装nodejs"><a href="#1-我们可以直接通过apt-get安装nodejs" class="headerlink" title="1.  我们可以直接通过apt-get安装nodejs"></a>1.  我们可以直接通过<code>apt-get</code>安装nodejs</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update //需要先刷新本地索引包</span><br><span class="line">sudo apt-get install nodejs //然后安装nodejs包</span><br><span class="line">sudo apt-get install npm    //安装npm包管理器</span><br></pre></td></tr></table></figure><h2 id="2-安装好的node版本较低，我们可以使用n模块升级node到你需要打版本"><a href="#2-安装好的node版本较低，我们可以使用n模块升级node到你需要打版本" class="headerlink" title="2. 安装好的node版本较低，我们可以使用n模块升级node到你需要打版本"></a>2. 安装好的node版本较低，我们可以使用n模块升级node到你需要打版本</h2><h4 id="1-node有一个-n模块，专门用来管理nodejs版本的。不过目前并不支持windows系统。我们先安装下"><a href="#1-node有一个-n模块，专门用来管理nodejs版本的。不过目前并不支持windows系统。我们先安装下" class="headerlink" title="1.  node有一个 n模块，专门用来管理nodejs版本的。不过目前并不支持windows系统。我们先安装下"></a>1.  node有一个 n模块，专门用来管理nodejs版本的。不过目前并不支持windows系统。我们先安装下</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g n</span><br></pre></td></tr></table></figure><h4 id="2-升级到制定版本，我们可以在n加上指定的版本号就可以"><a href="#2-升级到制定版本，我们可以在n加上指定的版本号就可以" class="headerlink" title="2.  升级到制定版本，我们可以在n加上指定的版本号就可以"></a>2.  升级到制定版本，我们可以在n加上指定的版本号就可以</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo n 6.10.2</span><br></pre></td></tr></table></figure><a id="more"></a><h4 id="3-还有一些常用打快捷方法"><a href="#3-还有一些常用打快捷方法" class="headerlink" title="3.  还有一些常用打快捷方法"></a>3.  还有一些常用打快捷方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo n latest   //安装最新打官方版本</span><br><span class="line">sudo n stanle   //安装最新打稳定版</span><br><span class="line">sudo n lts      //安装最新打lts官方版</span><br></pre></td></tr></table></figure><h4 id="4-删除版本"><a href="#4-删除版本" class="headerlink" title="4.  删除版本"></a>4.  删除版本</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo n rm 0.9.4</span><br><span class="line">sudo n -0.9.4</span><br></pre></td></tr></table></figure><ul><li>更多命令，我们可以使用<code>n --help</code>寻求帮助</li></ul><h1 id="ubuntu常用工具安装"><a href="#ubuntu常用工具安装" class="headerlink" title="ubuntu常用工具安装"></a>ubuntu常用工具安装</h1><h2 id="右上角任务栏显示cpu内存使用百分比，还可以显示网络传输速率"><a href="#右上角任务栏显示cpu内存使用百分比，还可以显示网络传输速率" class="headerlink" title="右上角任务栏显示cpu内存使用百分比，还可以显示网络传输速率"></a>右上角任务栏显示cpu内存使用百分比，还可以显示网络传输速率</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">sudo add-apt-repository ppa:fossfreedom/indicator-sysmonitor   //这里选择按enter键</span><br><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install indicator-sysmonitor</span><br><span class="line">//启动</span><br><span class="line">indicator-sysmonitor &amp;</span><br><span class="line">//ctrl+c后台运行该程序</span><br></pre></td></tr></table></figure><ul><li>启动之后，最好让程序开机自启动，鼠标右键点击标题栏上图标，弹出菜单，把<code>run on startup</code>后边打勾打上，然后进去advanced选项卡，就可以自定义配置需要显示在任务栏的项目啦</li></ul><h2 id="安装git"><a href="#安装git" class="headerlink" title="安装git"></a>安装git</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install git</span><br><span class="line">git config --global user.name &quot;name&quot;</span><br><span class="line">git config --global user.email &quot;your@email.com&quot;</span><br></pre></td></tr></table></figure><h2 id="安装编译工具"><a href="#安装编译工具" class="headerlink" title="安装编译工具"></a>安装编译工具</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install build-essential</span><br></pre></td></tr></table></figure><h2 id="安装yarn包管理工具"><a href="#安装yarn包管理工具" class="headerlink" title="安装yarn包管理工具"></a>安装yarn包管理工具</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo npm install -g yarn</span><br></pre></td></tr></table></figure><h2 id="安装cnpm镜像源"><a href="#安装cnpm镜像源" class="headerlink" title="安装cnpm镜像源"></a>安装cnpm镜像源</h2><blockquote><p>  下载包直接可以使用 <code>cnpm install name</code> 下载</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo npm install -g cnpm</span><br></pre></td></tr></table></figure><h2 id="安装nrm，node下载数据源管理器"><a href="#安装nrm，node下载数据源管理器" class="headerlink" title="安装nrm，node下载数据源管理器"></a>安装nrm，node下载数据源管理器</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo npm install -g nrm</span><br><span class="line">nrm -v //查看安装版本验证是否安装成功</span><br></pre></td></tr></table></figure><h4 id="可以查看当前所有的下载数据源链接"><a href="#可以查看当前所有的下载数据源链接" class="headerlink" title="可以查看当前所有的下载数据源链接"></a>可以查看当前所有的下载数据源链接</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nrm ls</span><br></pre></td></tr></table></figure><h4 id="测试所有打镜像源的响应速度，然后根据测试我们可以切换我们需要使用的下载源"><a href="#测试所有打镜像源的响应速度，然后根据测试我们可以切换我们需要使用的下载源" class="headerlink" title="测试所有打镜像源的响应速度，然后根据测试我们可以切换我们需要使用的下载源"></a>测试所有打镜像源的响应速度，然后根据测试我们可以切换我们需要使用的下载源</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nrm test</span><br><span class="line">nrm use [taobao]</span><br></pre></td></tr></table></figure><h1 id="github使用ssh"><a href="#github使用ssh" class="headerlink" title="github使用ssh"></a>github使用ssh</h1><blockquote><p>  我们使用git去github上传东西，一般都使用ssh免密方式，所以需要首先生成一枚ssh-key密钥，然后在home文件夹进入个人文件夹中，按ctrl+h，会显示所有隐藏文件，打开.ssh文件夹中的id_rsa.pub文件，把里边内容粘贴到github上就可以啦</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -b 4096 -C &quot;wangpansheng@qq.com&quot;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;ubuntu中快速安装nodejs&quot;&gt;&lt;a href=&quot;#ubuntu中快速安装nodejs&quot; class=&quot;headerlink&quot; title=&quot;ubuntu中快速安装nodejs&quot;&gt;&lt;/a&gt;ubuntu中快速安装nodejs&lt;/h1&gt;&lt;h2 id=&quot;1-我们可以直接通过apt-get安装nodejs&quot;&gt;&lt;a href=&quot;#1-我们可以直接通过apt-get安装nodejs&quot; class=&quot;headerlink&quot; title=&quot;1.  我们可以直接通过apt-get安装nodejs&quot;&gt;&lt;/a&gt;1.  我们可以直接通过&lt;code&gt;apt-get&lt;/code&gt;安装nodejs&lt;/h2&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;sudo apt-get update //需要先刷新本地索引包&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;sudo apt-get install nodejs //然后安装nodejs包&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;sudo apt-get install npm    //安装npm包管理器&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id=&quot;2-安装好的node版本较低，我们可以使用n模块升级node到你需要打版本&quot;&gt;&lt;a href=&quot;#2-安装好的node版本较低，我们可以使用n模块升级node到你需要打版本&quot; class=&quot;headerlink&quot; title=&quot;2. 安装好的node版本较低，我们可以使用n模块升级node到你需要打版本&quot;&gt;&lt;/a&gt;2. 安装好的node版本较低，我们可以使用n模块升级node到你需要打版本&lt;/h2&gt;&lt;h4 id=&quot;1-node有一个-n模块，专门用来管理nodejs版本的。不过目前并不支持windows系统。我们先安装下&quot;&gt;&lt;a href=&quot;#1-node有一个-n模块，专门用来管理nodejs版本的。不过目前并不支持windows系统。我们先安装下&quot; class=&quot;headerlink&quot; title=&quot;1.  node有一个 n模块，专门用来管理nodejs版本的。不过目前并不支持windows系统。我们先安装下&quot;&gt;&lt;/a&gt;1.  node有一个 n模块，专门用来管理nodejs版本的。不过目前并不支持windows系统。我们先安装下&lt;/h4&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;npm install -g n&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h4 id=&quot;2-升级到制定版本，我们可以在n加上指定的版本号就可以&quot;&gt;&lt;a href=&quot;#2-升级到制定版本，我们可以在n加上指定的版本号就可以&quot; class=&quot;headerlink&quot; title=&quot;2.  升级到制定版本，我们可以在n加上指定的版本号就可以&quot;&gt;&lt;/a&gt;2.  升级到制定版本，我们可以在n加上指定的版本号就可以&lt;/h4&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;sudo n 6.10.2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="linux" scheme="https://wangpansheng.github.io/tags/linux/"/>
    
      <category term="ubuntu" scheme="https://wangpansheng.github.io/tags/ubuntu/"/>
    
  </entry>
  
  <entry>
    <title>centos-01</title>
    <link href="https://wangpansheng.github.io/2017/03/03/centos-01/"/>
    <id>https://wangpansheng.github.io/2017/03/03/centos-01/</id>
    <published>2017-03-03T07:44:10.000Z</published>
    <updated>2018-01-31T12:34:56.746Z</updated>
    
    <content type="html"><![CDATA[<h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><pre><code><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//查看当前centos系统的版本</span><br><span class="line">cat /etc/redhat-release</span><br><span class="line">//查看系统内核版本是32位还是64位</span><br><span class="line">uname -r</span><br><span class="line">//安装cnpm</span><br><span class="line">npm install cnpm -g --registry=https://registry.npm.taobao.org</span><br></pre></td></tr></table></figure></code></pre><h2 id="添加用户"><a href="#添加用户" class="headerlink" title="添加用户"></a>添加用户</h2><blockquote><p>  在企业生产中，一般不会直接使用root来操作，可以通过命令创建用户，并且进行切换，普通用户下，前边显示的是$符号，root下显示的是#</p></blockquote><a id="more"></a><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">useradd username    //添加用户名</span><br><span class="line">passwd username     //给刚才添加的用户，设置密码，然后会提示输入密码，输入两次就可以了</span><br><span class="line">su - username       //可以切换到指定的用户</span><br><span class="line">su - root           //可以切换到root</span><br><span class="line">whoami              //可以查看当前用户是谁</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;常用命令&quot;&gt;&lt;a href=&quot;#常用命令&quot; class=&quot;headerlink&quot; title=&quot;常用命令&quot;&gt;&lt;/a&gt;常用命令&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;//查看当前centos系统的版本&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;cat /etc/redhat-release&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//查看系统内核版本是32位还是64位&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;uname -r&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//安装cnpm&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;npm install cnpm -g --registry=https://registry.npm.taobao.org&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&quot;添加用户&quot;&gt;&lt;a href=&quot;#添加用户&quot; class=&quot;headerlink&quot; title=&quot;添加用户&quot;&gt;&lt;/a&gt;添加用户&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;  在企业生产中，一般不会直接使用root来操作，可以通过命令创建用户，并且进行切换，普通用户下，前边显示的是$符号，root下显示的是#&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="centos" scheme="https://wangpansheng.github.io/tags/centos/"/>
    
  </entry>
  
  <entry>
    <title>NodeJS构建express框架开发简单应用</title>
    <link href="https://wangpansheng.github.io/2017/01/10/nodeJS%E6%9E%84%E5%BB%BAexpress%E6%A1%86%E6%9E%B6%E5%BC%80%E5%8F%91%E7%AE%80%E5%8D%95%E5%BA%94%E7%94%A8/"/>
    <id>https://wangpansheng.github.io/2017/01/10/nodeJS构建express框架开发简单应用/</id>
    <published>2017-01-10T13:39:28.000Z</published>
    <updated>2018-01-31T12:37:12.974Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>  使用node express简单构建，配合MongoDB数据库，实现简单的增删改查操作</p></blockquote><h2 id="首先我们需要构建express本地框架结构"><a href="#首先我们需要构建express本地框架结构" class="headerlink" title="首先我们需要构建express本地框架结构"></a>首先我们需要构建express本地框架结构</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">express demo</span><br><span class="line">//在demo文件夹中构建express结构</span><br></pre></td></tr></table></figure><h2 id="然后我们运行一下，"><a href="#然后我们运行一下，" class="headerlink" title="然后我们运行一下，"></a>然后我们运行一下，</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm start</span><br></pre></td></tr></table></figure><p>执行之后，我们在浏览器打开localhost:3000就可以看到初始化的页面，</p><h2 id="因为我们是使用-MongoDb数据库，所以需要安装mongodb的nodeJS包，"><a href="#因为我们是使用-MongoDb数据库，所以需要安装mongodb的nodeJS包，" class="headerlink" title="因为我们是使用 MongoDb数据库，所以需要安装mongodb的nodeJS包，"></a>因为我们是使用 MongoDb数据库，所以需要安装mongodb的nodeJS包，</h2><p>mongodb包的api基本上mongodb数据库的命令行操作命令差不多，所以，如果你比较清楚命令行操作命令，使用起来就会非常方便，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//安装mongodb包</span><br><span class="line">npm install mongodb --save</span><br><span class="line">//安装依赖包</span><br><span class="line">npm install</span><br></pre></td></tr></table></figure></p><p>至此，所有的准备工作基本完成，当然，前提你已经装好mongodb数据库，而且在使用的时候，需要全程开启数据库服务器。mongodb数据库的安装，我以前有文章有介绍过，有兴趣的可以去看看。</p><h2 id="我们使用MVC架构来实现针对数据库的增删改查，"><a href="#我们使用MVC架构来实现针对数据库的增删改查，" class="headerlink" title="我们使用MVC架构来实现针对数据库的增删改查，"></a>我们使用MVC架构来实现针对数据库的增删改查，</h2><ul><li>我们创建一个文件夹 module，就是连接控制数据库的文件。</li><li>我们使用routes来代替controller同样的功能，来连接视图层和数据库的连接。</li><li>我们的整体逻辑是，我们路由中添加一个get请求，请求中调用module中的一个操作方法，然后module中的添加方法，再去调用数据库连接，然后在使用操作api操作数据库。<h2 id="在module中首先连接到数据库"><a href="#在module中首先连接到数据库" class="headerlink" title="在module中首先连接到数据库"></a>在module中首先连接到数据库</h2></li></ul><a id="more"></a><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//得到MongoClient对象</span></span><br><span class="line"><span class="keyword">var</span> MongoClient = <span class="built_in">require</span>(<span class="string">"mongodb"</span>).MongoClient;</span><br><span class="line"><span class="keyword">var</span> url = <span class="string">"数据库主机ip:port/数据库名"</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span>(<span class="params">callback</span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">    MongoClient.connect(url,<span class="function"><span class="keyword">function</span>(<span class="params">err,db</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(err)&#123;</span><br><span class="line">            <span class="comment">//代表连接失败</span></span><br><span class="line">        <span class="keyword">return</span> callback(err);</span><br><span class="line">        &#125;</span><br><span class="line">        callback(<span class="literal">null</span>,db)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;  使用node express简单构建，配合MongoDB数据库，实现简单的增删改查操作&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;首先我们需要构建express本地框架结构&quot;&gt;&lt;a href=&quot;#首先我们需要构建express本地框架结构&quot; class=&quot;headerlink&quot; title=&quot;首先我们需要构建express本地框架结构&quot;&gt;&lt;/a&gt;首先我们需要构建express本地框架结构&lt;/h2&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;express demo&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//在demo文件夹中构建express结构&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id=&quot;然后我们运行一下，&quot;&gt;&lt;a href=&quot;#然后我们运行一下，&quot; class=&quot;headerlink&quot; title=&quot;然后我们运行一下，&quot;&gt;&lt;/a&gt;然后我们运行一下，&lt;/h2&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;npm start&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;执行之后，我们在浏览器打开localhost:3000就可以看到初始化的页面，&lt;/p&gt;
&lt;h2 id=&quot;因为我们是使用-MongoDb数据库，所以需要安装mongodb的nodeJS包，&quot;&gt;&lt;a href=&quot;#因为我们是使用-MongoDb数据库，所以需要安装mongodb的nodeJS包，&quot; class=&quot;headerlink&quot; title=&quot;因为我们是使用 MongoDb数据库，所以需要安装mongodb的nodeJS包，&quot;&gt;&lt;/a&gt;因为我们是使用 MongoDb数据库，所以需要安装mongodb的nodeJS包，&lt;/h2&gt;&lt;p&gt;mongodb包的api基本上mongodb数据库的命令行操作命令差不多，所以，如果你比较清楚命令行操作命令，使用起来就会非常方便，&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;//安装mongodb包&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;npm install mongodb --save&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//安装依赖包&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;npm install&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;至此，所有的准备工作基本完成，当然，前提你已经装好mongodb数据库，而且在使用的时候，需要全程开启数据库服务器。mongodb数据库的安装，我以前有文章有介绍过，有兴趣的可以去看看。&lt;/p&gt;
&lt;h2 id=&quot;我们使用MVC架构来实现针对数据库的增删改查，&quot;&gt;&lt;a href=&quot;#我们使用MVC架构来实现针对数据库的增删改查，&quot; class=&quot;headerlink&quot; title=&quot;我们使用MVC架构来实现针对数据库的增删改查，&quot;&gt;&lt;/a&gt;我们使用MVC架构来实现针对数据库的增删改查，&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;我们创建一个文件夹 module，就是连接控制数据库的文件。&lt;/li&gt;
&lt;li&gt;我们使用routes来代替controller同样的功能，来连接视图层和数据库的连接。&lt;/li&gt;
&lt;li&gt;我们的整体逻辑是，我们路由中添加一个get请求，请求中调用module中的一个操作方法，然后module中的添加方法，再去调用数据库连接，然后在使用操作api操作数据库。&lt;h2 id=&quot;在module中首先连接到数据库&quot;&gt;&lt;a href=&quot;#在module中首先连接到数据库&quot; class=&quot;headerlink&quot; title=&quot;在module中首先连接到数据库&quot;&gt;&lt;/a&gt;在module中首先连接到数据库&lt;/h2&gt;&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="NodeJS express" scheme="https://wangpansheng.github.io/tags/NodeJS-express/"/>
    
  </entry>
  
  <entry>
    <title>MongoDB数据库配合NodeJS简单使用</title>
    <link href="https://wangpansheng.github.io/2017/01/09/MongoDB%E7%AE%80%E5%8D%95%E5%AD%A6%E4%B9%A0/"/>
    <id>https://wangpansheng.github.io/2017/01/09/MongoDB简单学习/</id>
    <published>2017-01-09T11:11:15.000Z</published>
    <updated>2018-01-31T12:39:09.846Z</updated>
    
    <content type="html"><![CDATA[<h2 id="关于-MongoDB"><a href="#关于-MongoDB" class="headerlink" title="关于 MongoDB"></a>关于 MongoDB</h2><blockquote><p>  我们一般把数据库分为关系型数据库和非关系型数据库，MongoDB就是属于非关系型数据库的一种。</p></blockquote><ul><li>官网：<a href="https://www.mongodb.com/" target="_blank" rel="noopener">https://www.mongodb.com/</a></li><li>下载地址：<a href="https://www.mongodb.com/download-center?jmp=nav" target="_blank" rel="noopener">https://www.mongodb.com/download-center?jmp=nav</a></li></ul><h2 id="环境安装"><a href="#环境安装" class="headerlink" title="环境安装"></a>环境安装</h2><ul><li><a href="https://www.smartftp.com/support/kb/the-program-cant-start-because-api-ms-win-crt-runtime-l1-1-0dll-is-missing-f2702.html?lang=zh-CN" target="_blank" rel="noopener">https://www.smartftp.com/support/kb/the-program-cant-start-because-api-ms-win-crt-runtime-l1-1-0dll-is-missing-f2702.html?lang=zh-CN</a></li><li><a href="http://stackoverflow.com/questions/33265663/api-ms-win-crt-runtime-l1-1-0-dll-is-missing-when-opening-microsoft-office-file" target="_blank" rel="noopener">http://stackoverflow.com/questions/33265663/api-ms-win-crt-runtime-l1-1-0-dll-is-missing-when-opening-microsoft-office-file</a></li></ul><h2 id="启动和关闭-MongoDB-数据库服务程序"><a href="#启动和关闭-MongoDB-数据库服务程序" class="headerlink" title="启动和关闭 MongoDB 数据库服务程序"></a>启动和关闭 MongoDB 数据库服务程序</h2><p>mongod.exe 是我们要启动的服务器文件<br>mongo的客户端去连我们的服务器</p><ul><li><p>打开终端，输入 <code>mongod</code> 回车</p><ul><li><code>mongod</code> 命令用来启动 MongoDB 数据服务</li><li>MongoDB 服务默认将 C:/data/db 目录作为数据目录</li><li>所以你需要先在 C:/ 根目录新建一个目录：C:/data/db</li><li>当你执行 mongod 命令的时候，默认会去使用 c:/data/db 目录作为数据存储目录</li><li>如果你不想使用 c:/data/db 目录</li><li>mongod –dbpath=路径</li></ul></li><li><p>32位操作系统启动 MongoDB</p><ul><li><a href="http://jingyan.baidu.com/article/76a7e409e1bb49fc3b6e1516.html" target="_blank" rel="noopener">http://jingyan.baidu.com/article/76a7e409e1bb49fc3b6e1516.html</a></li><li><code>mongod --dbpath 数据存储路径 --journal --storageEngine=mmapv1</code><br>mongod –dbpath C:/data/db –journal –storageEngine=mmapv1`</li></ul></li></ul><a id="more"></a><h2 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h2><h3 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h3><ol><li>什么是数据？</li></ol><blockquote><p>数据是信息的表现形式和载体，可以是符号、文字、数字、语音、图像、视频等。通俗一点，数据就是信息，例如，个人信息、账户信息、家庭信息、企业信息、财务信息等等。</p></blockquote><ol><li>什么是数据库（Database，DB）？</li></ol><blockquote><p> 数据库是按照数据结构来组织、存储和管理数据的仓库。</p></blockquote><ol><li>为什么要使用数据库？</li></ol><blockquote><p>   我们需要使用数据库来存储我们网站的数据，然后通过增删改查进行数据交互，数据库，为我们提供了存储数据的仓库。</p></blockquote><ol><li>什么是数据库管理系统（DataBase Management System，DBMS）？</li></ol><blockquote><p> 数据库管理系统（DataBase Management System，DBMS）是为管理数据库而设计的大型电脑软件管理系统.例如，Oracle、Microsoft SQL Server、Access、MySQL、PostgreSQL、db2等等.我们可以简称这些数据库管理系统为数据库，虽然这种叫法不是很严谨，但是一般人都听的懂。</p></blockquote><ol><li>数据库的分类</li></ol><ul><li>关系型数据库 sql语言</li></ul><blockquote><p>关系数据库管理系统(Relational Database Management System)，<br>是将数据组织为相关的行和列的系统，而管理关系数据库的计算机软件就是关系数据库管理系统，常用的数据库软件有Oracle、SQL Server、MySQL等。</p></blockquote><ul><li>非关系型数据库 nosql<ul><li>内存数据库 redis</li><li>面向文档数据库 mongodb</li></ul></li></ul><h2 id="文档-document"><a href="#文档-document" class="headerlink" title="文档 document"></a>文档 document</h2><blockquote><p>文档是MongoDB中最基本的单元，里边包含多个键值对。</p></blockquote><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;name:"zhangsan",age:12&#125;</span><br><span class="line">&#123;name:"lisi"&#125;</span><br></pre></td></tr></table></figure><h2 id="集合-collection"><a href="#集合-collection" class="headerlink" title="集合 collection"></a>集合 collection</h2><blockquote><p>集合就是一组文档，特点是动态模式，集合中每一个文档都有可能不一样。但是在实际开发中，最好我们保存一样格式的文档。</p></blockquote><h2 id="常用指令"><a href="#常用指令" class="headerlink" title="常用指令"></a>常用指令</h2><h4 id="1-列出所有的数据库"><a href="#1-列出所有的数据库" class="headerlink" title="1.  列出所有的数据库"></a>1.  列出所有的数据库</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show dbs</span><br></pre></td></tr></table></figure><h4 id="2-进入或者新建数据库user"><a href="#2-进入或者新建数据库user" class="headerlink" title="2.  进入或者新建数据库user"></a>2.  进入或者新建数据库user</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">use user</span><br><span class="line">//如果已经有了user数据库，就会进入user数据库</span><br><span class="line">//如果没有user数据库，就会自动新建数据库，如果数据库中没有任何文档，则用show dbs不会显示该仓库</span><br></pre></td></tr></table></figure><h4 id="3-新建文档"><a href="#3-新建文档" class="headerlink" title="3.  新建文档"></a>3.  新建文档</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">db.user.insert(&#123;name:<span class="string">"wang"</span>&#125;)</span><br><span class="line">//在user集合中添加一条文档数据</span><br></pre></td></tr></table></figure><h4 id="4-查看user集合中的文档"><a href="#4-查看user集合中的文档" class="headerlink" title="4.  查看user集合中的文档"></a>4.  查看user集合中的文档</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.user.find()</span><br></pre></td></tr></table></figure><h4 id="5-更新文档内容"><a href="#5-更新文档内容" class="headerlink" title="5.  更新文档内容"></a>5.  更新文档内容</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.user.update(&#123;name:<span class="string">"wang"</span>&#125;,&#123;<span class="variable">$set</span>:&#123;name:<span class="string">"ang"</span>&#125;&#125;)</span><br></pre></td></tr></table></figure><h4 id="6-删除文档"><a href="#6-删除文档" class="headerlink" title="6.  删除文档"></a>6.  删除文档</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">db.user.remove(&#123;name:<span class="string">"wang"</span>&#125;)</span><br><span class="line">//如果不传入参数，则会直接删除集合</span><br></pre></td></tr></table></figure><h3 id="7-删除数据库"><a href="#7-删除数据库" class="headerlink" title="7.  删除数据库"></a>7.  删除数据库</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">use user</span><br><span class="line">db.dropDatabase()</span><br></pre></td></tr></table></figure><h2 id="js链接MongoDb"><a href="#js链接MongoDb" class="headerlink" title="js链接MongoDb"></a>js链接MongoDb</h2><blockquote><p> mongodb包提供的方法api和monggodb的命令基本一样，我们可以在nodejs中使用mongodb数据库进行增删改查操作。</p></blockquote><ul><li>api地址：<a href="http://mongodb.github.io/node-mongodb-native/2.2/api" target="_blank" rel="noopener">http://mongodb.github.io/node-mongodb-native/2.2/api</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;关于-MongoDB&quot;&gt;&lt;a href=&quot;#关于-MongoDB&quot; class=&quot;headerlink&quot; title=&quot;关于 MongoDB&quot;&gt;&lt;/a&gt;关于 MongoDB&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;  我们一般把数据库分为关系型数据库和非关系型数据库，MongoDB就是属于非关系型数据库的一种。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;官网：&lt;a href=&quot;https://www.mongodb.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.mongodb.com/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;下载地址：&lt;a href=&quot;https://www.mongodb.com/download-center?jmp=nav&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.mongodb.com/download-center?jmp=nav&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;环境安装&quot;&gt;&lt;a href=&quot;#环境安装&quot; class=&quot;headerlink&quot; title=&quot;环境安装&quot;&gt;&lt;/a&gt;环境安装&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://www.smartftp.com/support/kb/the-program-cant-start-because-api-ms-win-crt-runtime-l1-1-0dll-is-missing-f2702.html?lang=zh-CN&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.smartftp.com/support/kb/the-program-cant-start-because-api-ms-win-crt-runtime-l1-1-0dll-is-missing-f2702.html?lang=zh-CN&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://stackoverflow.com/questions/33265663/api-ms-win-crt-runtime-l1-1-0-dll-is-missing-when-opening-microsoft-office-file&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://stackoverflow.com/questions/33265663/api-ms-win-crt-runtime-l1-1-0-dll-is-missing-when-opening-microsoft-office-file&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;启动和关闭-MongoDB-数据库服务程序&quot;&gt;&lt;a href=&quot;#启动和关闭-MongoDB-数据库服务程序&quot; class=&quot;headerlink&quot; title=&quot;启动和关闭 MongoDB 数据库服务程序&quot;&gt;&lt;/a&gt;启动和关闭 MongoDB 数据库服务程序&lt;/h2&gt;&lt;p&gt;mongod.exe 是我们要启动的服务器文件&lt;br&gt;mongo的客户端去连我们的服务器&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;打开终端，输入 &lt;code&gt;mongod&lt;/code&gt; 回车&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;mongod&lt;/code&gt; 命令用来启动 MongoDB 数据服务&lt;/li&gt;
&lt;li&gt;MongoDB 服务默认将 C:/data/db 目录作为数据目录&lt;/li&gt;
&lt;li&gt;所以你需要先在 C:/ 根目录新建一个目录：C:/data/db&lt;/li&gt;
&lt;li&gt;当你执行 mongod 命令的时候，默认会去使用 c:/data/db 目录作为数据存储目录&lt;/li&gt;
&lt;li&gt;如果你不想使用 c:/data/db 目录&lt;/li&gt;
&lt;li&gt;mongod –dbpath=路径&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;32位操作系统启动 MongoDB&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://jingyan.baidu.com/article/76a7e409e1bb49fc3b6e1516.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://jingyan.baidu.com/article/76a7e409e1bb49fc3b6e1516.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;mongod --dbpath 数据存储路径 --journal --storageEngine=mmapv1&lt;/code&gt;&lt;br&gt;mongod –dbpath C:/data/db –journal –storageEngine=mmapv1`&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="MongoDB" scheme="https://wangpansheng.github.io/tags/MongoDB/"/>
    
      <category term="NodeJS" scheme="https://wangpansheng.github.io/tags/NodeJS/"/>
    
  </entry>
  
  <entry>
    <title>数组方法梳理</title>
    <link href="https://wangpansheng.github.io/2016/11/26/%E6%95%B0%E7%BB%84%E6%96%B9%E6%B3%95%E6%A2%B3%E7%90%86/"/>
    <id>https://wangpansheng.github.io/2016/11/26/数组方法梳理/</id>
    <published>2016-11-26T00:55:03.000Z</published>
    <updated>2018-01-31T12:42:33.014Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/bg2.jpg" alt="images/bg2.jpg"></p><blockquote><p>  由于发现对数组和字符串原生的方法有点记不太清了，所以打算梳理一下，把这写方法整理一下，加强自己的记忆。</p><p>  以下数组演示都以数组 数组arr=[1,2,3]为原始值；</p></blockquote><h3 id="length"><a href="#length" class="headerlink" title="length"></a>length</h3><ul><li><p>返回数组的长度</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arr.length;<span class="comment">//返回值是3</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="concat"><a href="#concat" class="headerlink" title="concat()"></a>concat()</h3><ul><li><p>连接两个或更多数组，并返回新数组，</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">arr.concat([<span class="number">8</span>,<span class="number">9</span>,<span class="number">0</span>]);</span><br><span class="line"><span class="comment">//返回是数组[1,2,3,8,9,0]</span></span><br><span class="line"><span class="comment">//不会修改原数组</span></span><br></pre></td></tr></table></figure></li></ul><a id="more"></a><h3 id="join"><a href="#join" class="headerlink" title="join()"></a>join()</h3><ul><li><p>把数组的所有元素放进一个新的字符串，元素根据指定的字符串分割</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">arr.join(<span class="string">""</span>);</span><br><span class="line"><span class="comment">//返回值是字符串123</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="pop"><a href="#pop" class="headerlink" title="pop()"></a>pop()</h3><ul><li><p>删除并返回最后一个元素</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">arr.pop();</span><br><span class="line"><span class="comment">//从数组中删除最后一个元素</span></span><br><span class="line"><span class="comment">//返回值是删除的元素，</span></span><br><span class="line"><span class="comment">//原数组被更改</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="push"><a href="#push" class="headerlink" title="push()"></a>push()</h3><ul><li>向数组最后添加一个或多个元素，并返回添加之后数组的长度<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">arr.push(<span class="number">3</span>);</span><br><span class="line"><span class="comment">//返回值是新数组长度</span></span><br><span class="line"><span class="comment">//原数组被更改</span></span><br><span class="line">arr.push([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]);</span><br><span class="line"><span class="comment">//这样调用，会把传入的数组当作数组一个元素</span></span><br><span class="line">arr.push(<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>);</span><br><span class="line"><span class="comment">//会把传入的值按照先后顺序放在数组的最后</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="reverse"><a href="#reverse" class="headerlink" title="reverse()"></a>reverse()</h3><ul><li><p>颠倒数组中元素的排序</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">arr.reverse();</span><br><span class="line"><span class="comment">//返回值和原数组都是反转之后的数组</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="shift"><a href="#shift" class="headerlink" title="shift()"></a>shift()</h3><ul><li><p>删除并返回数组的第一个元素</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">arr.shift();</span><br><span class="line"><span class="comment">//返回被删除的元素</span></span><br><span class="line"><span class="comment">//会修改原数组</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="unshift"><a href="#unshift" class="headerlink" title="unshift()"></a>unshift()</h3><ul><li>在数组最前添加一个或多个元素，返回新长度<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">arr.unshift([<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]);</span><br><span class="line">arr.unshift(<span class="number">2</span>,<span class="number">4</span>,<span class="number">4</span>);</span><br><span class="line"><span class="comment">//如果传入多个元素，传入的第一个元素会在数组的索引0上，第二个会在1上，以此类推，</span></span><br><span class="line"><span class="comment">//简单理解，传入多个元素，直接把传入的内容直接放在最前边；</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="slice"><a href="#slice" class="headerlink" title="slice()"></a>slice()</h3><ul><li><p>选取并返回数组中指定的元素</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">arr.slice(start,end);</span><br><span class="line"><span class="comment">//strat是开始索引值，end是结束索引值，不包含end索引的值</span></span><br><span class="line"><span class="comment">//如果索引值是负数，-1就是最后一个元素，以此类推</span></span><br><span class="line"><span class="comment">//如果没有第二个值，那么从start开始截取到数组结束</span></span><br><span class="line"><span class="comment">//不会修改原元素</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="sort"><a href="#sort" class="headerlink" title="sort()"></a>sort()</h3><ul><li><p>对数组的元素进行排序,直接对原数组进行排序，返回值也是排序后的新数组,如果不传参数，则是按照元素首字母排序，如果需要按照指定的规则排序，需要传入指定的函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arr.sort();</span><br></pre></td></tr></table></figure></li></ul><h3 id="splice"><a href="#splice" class="headerlink" title="splice()"></a>splice()</h3><ul><li><p>从数组中添加删除元素，返回被删除的元素</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">arr.splice(index,howmany,item1...itemx); </span><br><span class="line"><span class="comment">//index 添加或删除元素的索引位置</span></span><br><span class="line"><span class="comment">//howmany 要删除元素的个数，不删除可以设置为0</span></span><br><span class="line"><span class="comment">//item 要添加的元素</span></span><br><span class="line"><span class="comment">//返回值是删除的元素</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="toSource"><a href="#toSource" class="headerlink" title="toSource()"></a>toSource()</h3><ul><li>返回对象的源代码,只有火狐支持</li></ul><h3 id="toString-NaN"><a href="#toString-NaN" class="headerlink" title="toString()"></a>toString()</h3><ul><li>把数组转换为字符串，并返回结果</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/images/bg2.jpg&quot; alt=&quot;images/bg2.jpg&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;  由于发现对数组和字符串原生的方法有点记不太清了，所以打算梳理一下，把这写方法整理一下，加强自己的记忆。&lt;/p&gt;
&lt;p&gt;  以下数组演示都以数组 数组arr=[1,2,3]为原始值；&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;length&quot;&gt;&lt;a href=&quot;#length&quot; class=&quot;headerlink&quot; title=&quot;length&quot;&gt;&lt;/a&gt;length&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;返回数组的长度&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;arr.length;&lt;span class=&quot;comment&quot;&gt;//返回值是3&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;concat&quot;&gt;&lt;a href=&quot;#concat&quot; class=&quot;headerlink&quot; title=&quot;concat()&quot;&gt;&lt;/a&gt;concat()&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;连接两个或更多数组，并返回新数组，&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;arr.concat([&lt;span class=&quot;number&quot;&gt;8&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;9&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;]);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//返回是数组[1,2,3,8,9,0]&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//不会修改原数组&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="数组，js基础" scheme="https://wangpansheng.github.io/tags/%E6%95%B0%E7%BB%84%EF%BC%8Cjs%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>原生框架封装之插件开发</title>
    <link href="https://wangpansheng.github.io/2016/11/20/%E5%8E%9F%E7%94%9F%E6%A1%86%E6%9E%B6%E5%B0%81%E8%A3%85%E4%B9%8B%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91/"/>
    <id>https://wangpansheng.github.io/2016/11/20/原生框架封装之插件开发/</id>
    <published>2016-11-20T01:25:49.000Z</published>
    <updated>2018-01-31T12:42:33.010Z</updated>
    
    <content type="html"><![CDATA[<h2 id="cookie"><a href="#cookie" class="headerlink" title="cookie"></a>cookie</h2><ol><li><p>历史背景</p><ul><li>http https: 都是一种无状态、无连接的协议</li><li>tcp/ip 是一种长连接协议</li><li>无论什么用户都可以访问网址页面，在实际开发中，有些页面需要先验证身份才可以访问的，此时就需要http记录用户的状态，（登录状态），</li><li>但是http协议是无状态的，因此就诞生了session和cookie</li></ul></li><li><p>应用场景</p><ul><li>登录功能：记录登录状态，以及一些用户基本信息。</li><li>用户基本信息：昵称、头像地址、加密后的密码（记住密码）、用户名</li></ul></li><li><p>做cookie插件的目的</p></li></ol><ul><li>方便前端人员操作cookie</li></ul><a id="more"></a><h2 id="原生js操作cookie"><a href="#原生js操作cookie" class="headerlink" title="原生js操作cookie"></a>原生js操作cookie</h2><ol><li><p>获取</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.cookie</span><br></pre></td></tr></table></figure></li><li><p>操作</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.cookie = <span class="string">"username=guoguo"</span>;</span><br></pre></td></tr></table></figure></li><li><p>设置有效期</p><ul><li><p>默认如果没有设置cookie有效期，它就是一个会话的cookie，也就是说，当浏览器关闭时，该cookie的信息会被清除掉</p></li><li><p>在设置cookie有效期时，单位是天，在原生设置cookie有效期时，要给expiries赋值为截止日期；</p></li></ul></li><li><p>设置域名</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">domain=<span class="string">"xxx.com"</span></span><br></pre></td></tr></table></figure></li><li><p>设置路径</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">path=<span class="string">"/"</span></span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;cookie&quot;&gt;&lt;a href=&quot;#cookie&quot; class=&quot;headerlink&quot; title=&quot;cookie&quot;&gt;&lt;/a&gt;cookie&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;历史背景&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;http https: 都是一种无状态、无连接的协议&lt;/li&gt;
&lt;li&gt;tcp/ip 是一种长连接协议&lt;/li&gt;
&lt;li&gt;无论什么用户都可以访问网址页面，在实际开发中，有些页面需要先验证身份才可以访问的，此时就需要http记录用户的状态，（登录状态），&lt;/li&gt;
&lt;li&gt;但是http协议是无状态的，因此就诞生了session和cookie&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;应用场景&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;登录功能：记录登录状态，以及一些用户基本信息。&lt;/li&gt;
&lt;li&gt;用户基本信息：昵称、头像地址、加密后的密码（记住密码）、用户名&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;做cookie插件的目的&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;方便前端人员操作cookie&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="原生框架封装" scheme="https://wangpansheng.github.io/tags/%E5%8E%9F%E7%94%9F%E6%A1%86%E6%9E%B6%E5%B0%81%E8%A3%85/"/>
    
      <category term="js，jquery" scheme="https://wangpansheng.github.io/tags/js%EF%BC%8Cjquery/"/>
    
  </entry>
  
  <entry>
    <title>jqeury框架封装练习3</title>
    <link href="https://wangpansheng.github.io/2016/11/18/%E6%A1%86%E6%9E%B6%E5%B0%81%E8%A3%85%E7%BB%83%E4%B9%A03/"/>
    <id>https://wangpansheng.github.io/2016/11/18/框架封装练习3/</id>
    <published>2016-11-18T03:23:09.000Z</published>
    <updated>2018-01-31T12:42:27.854Z</updated>
    
    <content type="html"><![CDATA[<h2 id="DOM操作模块"><a href="#DOM操作模块" class="headerlink" title="DOM操作模块"></a>DOM操作模块</h2><h3 id="appendTO方法"><a href="#appendTO方法" class="headerlink" title="appendTO方法"></a>appendTO方法</h3><ol><li><p>语法：实例对象.appendTo(target);</p></li><li><p>功能：将调用者上的所有DOM元素，分别追加到目标元素上</p></li><li><p>target参数类型：</p><ul><li>选择器</li><li>DOM元素</li><li>DOM数组，伪数组</li></ul></li></ol><ul><li><p>为了更方便处理不同的类型，在实现时，首先统一target的参数类型，方便发i吗逻辑的处理</p></li><li><p>将target统一成itcast的对象，参数一致，便于处理，同时由于是itcast对象，就可以直接调用each方法进行遍历元素</p></li></ul><ol><li>实现思路</li></ol><ul><li>统一target类型，</li><li>遍历target，再遍历调用者</li><li>判断，当目标元素是不是第一个元素，如果是，不需要拷贝源节点，否则就要深拷贝源节点，</li><li>将上述得到的新节点，缓存起来到数组中，</li><li>再将新节点追加到dom元素中</li><li>将缓存的数组转换成itcast对象，作为appendTo的返回值，来实现链式编程。</li></ul><a id="more"></a><h3 id="append方法"><a href="#append方法" class="headerlink" title="append方法"></a>append方法</h3><ol><li><p>功能：    将传入参数追加给调用者。</p></li><li><p>思路：</p><ul><li>将传入实参转换成itcast对象</li><li>用传入的实参调用appendTo方法，将this作为目标元素传入appendTo方法</li><li>实现链式编程</li></ul></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;DOM操作模块&quot;&gt;&lt;a href=&quot;#DOM操作模块&quot; class=&quot;headerlink&quot; title=&quot;DOM操作模块&quot;&gt;&lt;/a&gt;DOM操作模块&lt;/h2&gt;&lt;h3 id=&quot;appendTO方法&quot;&gt;&lt;a href=&quot;#appendTO方法&quot; class=&quot;headerlink&quot; title=&quot;appendTO方法&quot;&gt;&lt;/a&gt;appendTO方法&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;语法：实例对象.appendTo(target);&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;功能：将调用者上的所有DOM元素，分别追加到目标元素上&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;target参数类型：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;选择器&lt;/li&gt;
&lt;li&gt;DOM元素&lt;/li&gt;
&lt;li&gt;DOM数组，伪数组&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;为了更方便处理不同的类型，在实现时，首先统一target的参数类型，方便发i吗逻辑的处理&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;将target统一成itcast的对象，参数一致，便于处理，同时由于是itcast对象，就可以直接调用each方法进行遍历元素&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;实现思路&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;统一target类型，&lt;/li&gt;
&lt;li&gt;遍历target，再遍历调用者&lt;/li&gt;
&lt;li&gt;判断，当目标元素是不是第一个元素，如果是，不需要拷贝源节点，否则就要深拷贝源节点，&lt;/li&gt;
&lt;li&gt;将上述得到的新节点，缓存起来到数组中，&lt;/li&gt;
&lt;li&gt;再将新节点追加到dom元素中&lt;/li&gt;
&lt;li&gt;将缓存的数组转换成itcast对象，作为appendTo的返回值，来实现链式编程。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="原生框架" scheme="https://wangpansheng.github.io/tags/%E5%8E%9F%E7%94%9F%E6%A1%86%E6%9E%B6/"/>
    
      <category term="JavaScript" scheme="https://wangpansheng.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>框架封装之Ajax</title>
    <link href="https://wangpansheng.github.io/2016/11/17/%E6%A1%86%E6%9E%B6%E5%B0%81%E8%A3%85%E4%B9%8BAjax/"/>
    <id>https://wangpansheng.github.io/2016/11/17/框架封装之Ajax/</id>
    <published>2016-11-17T01:31:26.000Z</published>
    <updated>2018-01-31T12:42:33.022Z</updated>
    
    <content type="html"><![CDATA[<h2 id="ajax请求步骤"><a href="#ajax请求步骤" class="headerlink" title="ajax请求步骤"></a>ajax请求步骤</h2><ol><li>创建请求对象</li><li>格式化数据</li><li>与服务器建立连接</li><li>监听请求状态</li><li>发送请求</li></ol><h2 id="创建请求对象"><a href="#创建请求对象" class="headerlink" title="创建请求对象"></a>创建请求对象</h2><ol><li>原生方法<ul><li>w3c:XMLHttpRequest</li><li>IE：ActiveXObject</li></ul></li></ol><h2 id="封装Ajax模块"><a href="#封装Ajax模块" class="headerlink" title="封装Ajax模块"></a>封装Ajax模块</h2><ol><li><p>确定Ajax配置的默认值</p><ul><li>url =&gt; “”</li><li>type =&gt; “get”</li><li>data =&gt; {}</li><li>success =&gt; null</li><li>fail =&gt; null</li><li>async =&gt; true</li><li>dataType =&gt; “json”</li><li>contentType =&gt; “application/x-www-form-ulencoded”</li></ul></li><li><p>ajax默认配置放在哪？</p><ul><li>要用一个对象来存储上述Ajax配置信息，像jQuery一样，将其放到工厂函数上；<br>放在工厂函数jq上</li></ul></li></ol><a id="more"></a><h3 id="改造extend方法"><a href="#改造extend方法" class="headerlink" title="改造extend方法"></a>改造extend方法</h3><ol><li>如果只传入一个参数，给this扩展成员，</li><li>或者传入两个以上，就是给第一个参数扩展成员，，</li></ol><h2 id="跨域"><a href="#跨域" class="headerlink" title="跨域"></a>跨域</h2><ol><li><p>jsonp跨域的一种方式，缺点：只能发送跨域get请求</p></li><li><p>本质：利用script标签的src属性可以跨域的特性</p></li><li><p>实现流程：</p><ul><li>创建script标签，添加到head下</li><li>常见一个全局函数，用来处理服务器响应的数据</li><li>指定script标签src的属性值，同时将全局函数发送到服务区</li><li>要与后台人员沟通，将发送全局函数的参数名告诉后台人员</li><li></li></ul></li><li>实现步骤：<ul><li>常见请求对象，script标签</li><li>格式化数据</li><li>创建一个全局函数，将函数添加到data内，</li><li>监听请求的状态-》使用timeout来做请求状态的监听，如果在超过时间内，表示成功，否则就报超时，</li><li>发送请求，-》给script标签指定src属性值</li></ul></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;ajax请求步骤&quot;&gt;&lt;a href=&quot;#ajax请求步骤&quot; class=&quot;headerlink&quot; title=&quot;ajax请求步骤&quot;&gt;&lt;/a&gt;ajax请求步骤&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;创建请求对象&lt;/li&gt;
&lt;li&gt;格式化数据&lt;/li&gt;
&lt;li&gt;与服务器建立连接&lt;/li&gt;
&lt;li&gt;监听请求状态&lt;/li&gt;
&lt;li&gt;发送请求&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;创建请求对象&quot;&gt;&lt;a href=&quot;#创建请求对象&quot; class=&quot;headerlink&quot; title=&quot;创建请求对象&quot;&gt;&lt;/a&gt;创建请求对象&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;原生方法&lt;ul&gt;
&lt;li&gt;w3c:XMLHttpRequest&lt;/li&gt;
&lt;li&gt;IE：ActiveXObject&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;封装Ajax模块&quot;&gt;&lt;a href=&quot;#封装Ajax模块&quot; class=&quot;headerlink&quot; title=&quot;封装Ajax模块&quot;&gt;&lt;/a&gt;封装Ajax模块&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;确定Ajax配置的默认值&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;url =&amp;gt; “”&lt;/li&gt;
&lt;li&gt;type =&amp;gt; “get”&lt;/li&gt;
&lt;li&gt;data =&amp;gt; {}&lt;/li&gt;
&lt;li&gt;success =&amp;gt; null&lt;/li&gt;
&lt;li&gt;fail =&amp;gt; null&lt;/li&gt;
&lt;li&gt;async =&amp;gt; true&lt;/li&gt;
&lt;li&gt;dataType =&amp;gt; “json”&lt;/li&gt;
&lt;li&gt;contentType =&amp;gt; “application/x-www-form-ulencoded”&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;ajax默认配置放在哪？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;要用一个对象来存储上述Ajax配置信息，像jQuery一样，将其放到工厂函数上；&lt;br&gt;放在工厂函数jq上&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="框架封装，ajax" scheme="https://wangpansheng.github.io/tags/%E6%A1%86%E6%9E%B6%E5%B0%81%E8%A3%85%EF%BC%8Cajax/"/>
    
  </entry>
  
  <entry>
    <title>原生框架封装练习02</title>
    <link href="https://wangpansheng.github.io/2016/11/17/%E5%8E%9F%E7%94%9F%E6%A1%86%E6%9E%B6%E5%B0%81%E8%A3%85%E7%BB%83%E4%B9%A02/"/>
    <id>https://wangpansheng.github.io/2016/11/17/原生框架封装练习2/</id>
    <published>2016-11-17T01:26:35.000Z</published>
    <updated>2018-01-31T12:42:33.004Z</updated>
    
    <content type="html"><![CDATA[<h2 id="工具类方法与功能类方法"><a href="#工具类方法与功能类方法" class="headerlink" title="工具类方法与功能类方法"></a>工具类方法与功能类方法</h2><ol><li><p>工具类方法：</p><ul><li>可以在内部使用，也可以给使用者使用，不需要常见实例就可以调用的</li></ul></li><li><p>功能类方法：</p><ul><li>框架内部的对象的方法，必须使用该对象去调用，操作dom元素的方法</li></ul></li></ol><h2 id="类型判断方法"><a href="#类型判断方法" class="headerlink" title="类型判断方法"></a>类型判断方法</h2><ol><li><p>isString方法：判断指定 参数是不是字符串类型，</p></li><li><p>isHTML：判断指定参数是不是html字符串</p><ul><li>以&lt;开头，以&gt;结尾，长度不小于3的字符串</li></ul></li><li><p>isDOM：判断指定的参数是不是dom对象</p><ul><li>如果参数不为null或undefined，并且具有nodetype属性，那么类型就是dom对象</li></ul></li><li><p>isArrayLink：判断指定参数是不是数组或伪数组</p><ul><li>如果对象的length属性是number类型</li></ul></li></ol><a id="more"></a><ol><li><p>isFunction：</p><ul><li></li></ul></li><li><p>iswindow：判断指定参数是不是window</p><ul><li>如果参数值不是null undefined，并具有window属性指向自己，那么该对象就是window</li></ul></li></ol><h2 id="工具类方法"><a href="#工具类方法" class="headerlink" title="工具类方法"></a>工具类方法</h2><ol><li><p>type方法：</p></li><li><p>ParseHTML方法：将html字符串转换为对应的元素节点</p></li></ol><h2 id="selector参数类型与逻辑"><a href="#selector参数类型与逻辑" class="headerlink" title="selector参数类型与逻辑"></a>selector参数类型与逻辑</h2><h2 id="保持itcast对象是伪数组"><a href="#保持itcast对象是伪数组" class="headerlink" title="保持itcast对象是伪数组"></a>保持itcast对象是伪数组</h2><ul><li>在itcast的原型上添加length=0；表示itcast对象默认的属相为0；</li></ul><h2 id="功能类方法toArray"><a href="#功能类方法toArray" class="headerlink" title="功能类方法toArray"></a>功能类方法toArray</h2><ol><li></li><li><p>功能：将itcast对象，转换成真数组</p></li><li><p>实现思路：借调数组的slice方法，</p></li></ol><h2 id="功能类get方法"><a href="#功能类get方法" class="headerlink" title="功能类get方法"></a>功能类get方法</h2><ol><li><p>语法：<code>itcast对象.get( index )</code></p></li><li><p>功能：根据索引获取指定的dom元素</p></li><li><p>实现思路：</p><ul><li>判断index是不是null undefined值，如果是就返回一个数组，存储itcast对象所有的dom元素</li><li>判断index是否小于0，是 就index+this.length转换成自然数索引值，</li><li>返回this[index]</li></ul></li></ol><h2 id="鸭子类型Ducking-Type"><a href="#鸭子类型Ducking-Type" class="headerlink" title="鸭子类型Ducking Type"></a>鸭子类型Ducking Type</h2><ul><li><p>如果一个东西，走路像鸭子，声音像鸭子，那么它就是鸭子。</p></li><li><p>实现伪数组对象，在控制台显示时是以数组形式显示</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;工具类方法与功能类方法&quot;&gt;&lt;a href=&quot;#工具类方法与功能类方法&quot; class=&quot;headerlink&quot; title=&quot;工具类方法与功能类方法&quot;&gt;&lt;/a&gt;工具类方法与功能类方法&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;工具类方法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;可以在内部使用，也可以给使用者使用，不需要常见实例就可以调用的&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;功能类方法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;框架内部的对象的方法，必须使用该对象去调用，操作dom元素的方法&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;类型判断方法&quot;&gt;&lt;a href=&quot;#类型判断方法&quot; class=&quot;headerlink&quot; title=&quot;类型判断方法&quot;&gt;&lt;/a&gt;类型判断方法&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;isString方法：判断指定 参数是不是字符串类型，&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;isHTML：判断指定参数是不是html字符串&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;以&amp;lt;开头，以&amp;gt;结尾，长度不小于3的字符串&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;isDOM：判断指定的参数是不是dom对象&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果参数不为null或undefined，并且具有nodetype属性，那么类型就是dom对象&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;isArrayLink：判断指定参数是不是数组或伪数组&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果对象的length属性是number类型&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="原生框架封装" scheme="https://wangpansheng.github.io/tags/%E5%8E%9F%E7%94%9F%E6%A1%86%E6%9E%B6%E5%B0%81%E8%A3%85/"/>
    
      <category term="原生js实现jq" scheme="https://wangpansheng.github.io/tags/%E5%8E%9F%E7%94%9Fjs%E5%AE%9E%E7%8E%B0jq/"/>
    
  </entry>
  
  <entry>
    <title>jquery框架封装练习01</title>
    <link href="https://wangpansheng.github.io/2016/11/15/%E5%8E%9F%E7%94%9F%E6%A1%86%E6%9E%B6%E5%B0%81%E8%A3%85%E7%BB%83%E4%B9%A001/"/>
    <id>https://wangpansheng.github.io/2016/11/15/原生框架封装练习01/</id>
    <published>2016-11-15T07:07:04.000Z</published>
    <updated>2018-01-31T12:39:09.852Z</updated>
    
    <content type="html"><![CDATA[<ul><li><p>我们通过原生的js实现一些jq的功能，通过练习，锻炼我们的分析问题的能力。锻炼编程的思维能力。</p></li><li><p>查询DOM方法</p></li><li>操作DOM方法<ul><li>appendTo</li><li>append</li><li>prependTo</li><li>prepend</li><li>next/prev</li><li>nextAll/prevAll</li><li>before</li><li>after</li><li>parent /parents</li><li>nextSibling</li><li>attr</li><li>prop</li><li>val</li><li>html</li><li>text</li><li>css</li><li>addClass</li><li>hasClass</li><li>removeClass</li><li>toggleClass</li><li>on</li><li>off</li><li>click /dbclick/keydown</li><li>$.ajax</li></ul></li></ul><h2 id="jQuery框架结构"><a href="#jQuery框架结构" class="headerlink" title="jQuery框架结构"></a>jQuery框架结构</h2><ol><li>为了防止对变量和全局对象的污染，使用沙箱模式</li><li>jq的功能是查询DOM和操作DOM，<ul><li>在查询时，通过选择器来查询。因此要使用函数去实现Dom元素的查询。在实现时，要先定义一个函数init，</li><li>查询到DOM后，要对这些DOM进行操作，此时，要使用面向对象编程的方式来实现，创建一个对象，然后通过该对象的方法来实现操作查询到的DOM元素。</li></ul></li><li>由于框架的结构在完成之后，不允许任何使用者随意改动，所以用户如果想要扩展方法，就必须向其能拿到的对象上扩展，$-&gt;createinit，也就是工厂函数以及其原型。最终要实现init对象继承自createinit函数的原型。</li></ol><a id="more"></a><h2 id="jQuery对象的本质"><a href="#jQuery对象的本质" class="headerlink" title="jQuery对象的本质"></a>jQuery对象的本质</h2><pre><code>是一个伪数组对象，在自然数的索引上存储的是查询到的DOM元素，本质是jQuery原型上的init构造函数的实例。</code></pre><h2 id="init构造函数的参数类型"><a href="#init构造函数的参数类型" class="headerlink" title="init构造函数的参数类型"></a>init构造函数的参数类型</h2><ul><li>构造函数中传入参数的类型有很多，所以我们需要对传入的参数进行判断，根据传入参数的不同，实现不同的功能。</li></ul><ol><li><p>string</p><ul><li>html字符串：创建对应的html元素</li><li>选择器：在DOM树上查询元素</li></ul></li><li><p>dom元素</p><ul><li>将其转换成init对象</li></ul></li></ol><ol><li><p>dom数组和伪数组</p><ul><li>转换成init对象</li></ul></li><li><p>函数</p><ul><li>其实就是入口函数</li><li>监听dom树是否加载完毕，如果加载完毕就执行函数</li></ul></li><li><p>非法值 null undefined</p></li></ol><ul><li>返回空的init对象</li></ul><h2 id="添加类型判断方法"><a href="#添加类型判断方法" class="headerlink" title="添加类型判断方法"></a>添加类型判断方法</h2><ul><li>根据上面的类型需要做出判断，添加对应的怕段方法</li></ul><ol><li><p>isString方法：判断是否为字符串</p></li><li><p>isHTML方法：判断是否为html字符串</p></li><li><p>isDOM方法：判断是否是dom节点</p></li><li><p>isArrayLike方法：判断是否为数组或伪数组对象</p></li><li><p>isFunction方法：判断是否为函数类型</p></li><li><p>isWindow方法：判断是否为window对象</p></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;&lt;p&gt;我们通过原生的js实现一些jq的功能，通过练习，锻炼我们的分析问题的能力。锻炼编程的思维能力。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;查询DOM方法&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;操作DOM方法&lt;ul&gt;
&lt;li&gt;appendTo&lt;/li&gt;
&lt;li&gt;append&lt;/li&gt;
&lt;li&gt;prependTo&lt;/li&gt;
&lt;li&gt;prepend&lt;/li&gt;
&lt;li&gt;next/prev&lt;/li&gt;
&lt;li&gt;nextAll/prevAll&lt;/li&gt;
&lt;li&gt;before&lt;/li&gt;
&lt;li&gt;after&lt;/li&gt;
&lt;li&gt;parent /parents&lt;/li&gt;
&lt;li&gt;nextSibling&lt;/li&gt;
&lt;li&gt;attr&lt;/li&gt;
&lt;li&gt;prop&lt;/li&gt;
&lt;li&gt;val&lt;/li&gt;
&lt;li&gt;html&lt;/li&gt;
&lt;li&gt;text&lt;/li&gt;
&lt;li&gt;css&lt;/li&gt;
&lt;li&gt;addClass&lt;/li&gt;
&lt;li&gt;hasClass&lt;/li&gt;
&lt;li&gt;removeClass&lt;/li&gt;
&lt;li&gt;toggleClass&lt;/li&gt;
&lt;li&gt;on&lt;/li&gt;
&lt;li&gt;off&lt;/li&gt;
&lt;li&gt;click /dbclick/keydown&lt;/li&gt;
&lt;li&gt;$.ajax&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;jQuery框架结构&quot;&gt;&lt;a href=&quot;#jQuery框架结构&quot; class=&quot;headerlink&quot; title=&quot;jQuery框架结构&quot;&gt;&lt;/a&gt;jQuery框架结构&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;为了防止对变量和全局对象的污染，使用沙箱模式&lt;/li&gt;
&lt;li&gt;jq的功能是查询DOM和操作DOM，&lt;ul&gt;
&lt;li&gt;在查询时，通过选择器来查询。因此要使用函数去实现Dom元素的查询。在实现时，要先定义一个函数init，&lt;/li&gt;
&lt;li&gt;查询到DOM后，要对这些DOM进行操作，此时，要使用面向对象编程的方式来实现，创建一个对象，然后通过该对象的方法来实现操作查询到的DOM元素。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;由于框架的结构在完成之后，不允许任何使用者随意改动，所以用户如果想要扩展方法，就必须向其能拿到的对象上扩展，$-&amp;gt;createinit，也就是工厂函数以及其原型。最终要实现init对象继承自createinit函数的原型。&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="js" scheme="https://wangpansheng.github.io/tags/js/"/>
    
      <category term="原生js实现jq，原生框架封装" scheme="https://wangpansheng.github.io/tags/%E5%8E%9F%E7%94%9Fjs%E5%AE%9E%E7%8E%B0jq%EF%BC%8C%E5%8E%9F%E7%94%9F%E6%A1%86%E6%9E%B6%E5%B0%81%E8%A3%85/"/>
    
  </entry>
  
  <entry>
    <title>JS原型链总结</title>
    <link href="https://wangpansheng.github.io/2016/10/10/js%E5%8E%9F%E5%9E%8B/"/>
    <id>https://wangpansheng.github.io/2016/10/10/js原型/</id>
    <published>2016-10-10T13:22:24.000Z</published>
    <updated>2018-01-31T12:39:09.828Z</updated>
    
    <content type="html"><![CDATA[<h2 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h2><h3 id="定义：是函数的prototype属性所引用的对象"><a href="#定义：是函数的prototype属性所引用的对象" class="headerlink" title="定义：是函数的prototype属性所引用的对象"></a>定义：是函数的prototype属性所引用的对象</h3><h3 id="目的：为了同类对象之间的数据共享"><a href="#目的：为了同类对象之间的数据共享" class="headerlink" title="目的：为了同类对象之间的数据共享"></a>目的：为了同类对象之间的数据共享</h3><h3 id="实际开发的使用"><a href="#实际开发的使用" class="headerlink" title="实际开发的使用"></a>实际开发的使用</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// 1: 定义构造函数，实现函数体部分</span></span><br><span class="line"><span class="comment">// 使用构造函数 结合原型</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age, sex</span>) </span>&#123;</span><br><span class="line"><span class="comment">// 特有的属性写在这里</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 2：将该对象相关的方法定义在原型上</span></span><br><span class="line"><span class="comment">// 将共有的属性（一般是方法）</span></span><br><span class="line">Person.prototype.say = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line">Person.prototype.run = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line">Person.prototype = &#123;</span><br><span class="line"><span class="keyword">constructor</span>: Person,</span><br><span class="line">say: function() &#123;&#125;,</span><br><span class="line">run: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 3：创建对象</span></span><br><span class="line"><span class="keyword">var</span> zs = <span class="keyword">new</span> Person();</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><h3 id="定义：指一个对象有权去访问另一个对象上的成员"><a href="#定义：指一个对象有权去访问另一个对象上的成员" class="headerlink" title="定义：指一个对象有权去访问另一个对象上的成员"></a>定义：指一个对象有权去访问另一个对象上的成员</h3><h3 id="继承的实现"><a href="#继承的实现" class="headerlink" title="继承的实现"></a>继承的实现</h3><ol><li><p>原型式</p></li><li><p>混入式</p></li><li><p>借用构造函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Animal</span>(<span class="params"> name, age, sex </span>) </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line"><span class="keyword">this</span>.age = age;</span><br><span class="line"><span class="keyword">this</span>.sex = sex;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"> name, age, sex, phoneNo </span>) </span>&#123;</span><br><span class="line">Animal.call( <span class="keyword">this</span>, name, age, sex );</span><br><span class="line"><span class="keyword">this</span>.phoneNo = phoneNo;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> zs = <span class="keyword">new</span> Person( <span class="string">'张三'</span>, <span class="number">18</span>, <span class="string">'boy'</span>, <span class="string">'13838383838'</span> );</span><br></pre></td></tr></table></figure></li></ol><h2 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h2><h3 id="本质是通过-proto-属性连接起来的，体现继承层次关系的。"><a href="#本质是通过-proto-属性连接起来的，体现继承层次关系的。" class="headerlink" title="本质是通过__proto__属性连接起来的，体现继承层次关系的。"></a>本质是通过__proto__属性连接起来的，体现继承层次关系的。</h3><h3 id="掌握程度"><a href="#掌握程度" class="headerlink" title="掌握程度"></a>掌握程度</h3><ol><li><p>给定一个对象，可以迅速找到该对象的原型链</p></li><li><p>找到该对象的三口之家</p></li></ol><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h3 id="函数是js的一等公民"><a href="#函数是js的一等公民" class="headerlink" title="函数是js的一等公民"></a>函数是js的一等公民</h3><ol><li><p>函数有双重身份</p><ul><li>对象-可以添加属性和方法–静态成员</li><li>函数-在调用时，就存在四种调用模式；递归调用</li></ul></li><li><p>可以嵌套使用</p><ul><li>js使用词法作用域，那么会产生作用域链</li></ul></li><li><p>可以作为其他函数的实参</p><ul><li>回调函数</li></ul></li><li><p>可以作为其他函数的返回值</p><ul><li>闭包</li></ul></li><li><p>可以限定作用域</p></li><li><p>可以作为对象的属性值<br>```</p></li></ol><tag>哈哈哈哈</tag>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;原型&quot;&gt;&lt;a href=&quot;#原型&quot; class=&quot;headerlink&quot; title=&quot;原型&quot;&gt;&lt;/a&gt;原型&lt;/h2&gt;&lt;h3 id=&quot;定义：是函数的prototype属性所引用的对象&quot;&gt;&lt;a href=&quot;#定义：是函数的prototype属性所引用的对象&quot; class=&quot;headerlink&quot; title=&quot;定义：是函数的prototype属性所引用的对象&quot;&gt;&lt;/a&gt;定义：是函数的prototype属性所引用的对象&lt;/h3&gt;&lt;h3 id=&quot;目的：为了同类对象之间的数据共享&quot;&gt;&lt;a href=&quot;#目的：为了同类对象之间的数据共享&quot; class=&quot;headerlink&quot; title=&quot;目的：为了同类对象之间的数据共享&quot;&gt;&lt;/a&gt;目的：为了同类对象之间的数据共享&lt;/h3&gt;&lt;h3 id=&quot;实际开发的使用&quot;&gt;&lt;a href=&quot;#实际开发的使用&quot; class=&quot;headerlink&quot; title=&quot;实际开发的使用&quot;&gt;&lt;/a&gt;实际开发的使用&lt;/h3&gt;&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt; &lt;span class=&quot;comment&quot;&gt;// 1: 定义构造函数，实现函数体部分&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 使用构造函数 结合原型&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Person&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;name, age, sex&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;comment&quot;&gt;// 特有的属性写在这里&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 2：将该对象相关的方法定义在原型上&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 将共有的属性（一般是方法）&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Person.prototype.say = &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;&amp;#123;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Person.prototype.run = &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;&amp;#123;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 或者&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Person.prototype = &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;constructor&lt;/span&gt;: Person,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	say: function() &amp;#123;&amp;#125;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	run: &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;&amp;#123;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 3：创建对象&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; zs = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Person();&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="JS" scheme="https://wangpansheng.github.io/tags/JS/"/>
    
      <category term="函数" scheme="https://wangpansheng.github.io/tags/%E5%87%BD%E6%95%B0/"/>
    
      <category term="原型" scheme="https://wangpansheng.github.io/tags/%E5%8E%9F%E5%9E%8B/"/>
    
      <category term="原型链" scheme="https://wangpansheng.github.io/tags/%E5%8E%9F%E5%9E%8B%E9%93%BE/"/>
    
  </entry>
  
  <entry>
    <title>canvas入门2</title>
    <link href="https://wangpansheng.github.io/2016/09/11/canvas%E5%85%A5%E9%97%A82/"/>
    <id>https://wangpansheng.github.io/2016/09/11/canvas入门2/</id>
    <published>2016-09-11T00:54:50.000Z</published>
    <updated>2018-01-31T12:34:48.517Z</updated>
    
    <content type="html"><![CDATA[<ul><li>懒加载：现在不加载，用的时候再加载，</li></ul><h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2><ol><li><p>移动的小球 实线思路：</p><ul><li>简单版</li></ul><ol><li>利用计时器，定时执行</li><li>首先绘制一个圆形，圆从左上角出来，然后定时改变圆心的位置，再进行绘制，</li><li>等到x轴的坐标大于w或者小于0，改变每一步的正负值，使其反向运动，</li></ol><ul><li>鼠标进入再鼠标所在位置绘制圆形，然后开始下落</li></ul></li><li><p>时钟案例</p></li></ol><a id="more"></a><pre><code>- 实现效果   ![cloc](/images/clock.png)- 实现思路1.  ​绘制表盘</code></pre><h2 id="待续"><a href="#待续" class="headerlink" title="待续"></a>待续</h2>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;懒加载：现在不加载，用的时候再加载，&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;案例&quot;&gt;&lt;a href=&quot;#案例&quot; class=&quot;headerlink&quot; title=&quot;案例&quot;&gt;&lt;/a&gt;案例&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;移动的小球 实线思路：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;简单版&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;利用计时器，定时执行&lt;/li&gt;
&lt;li&gt;首先绘制一个圆形，圆从左上角出来，然后定时改变圆心的位置，再进行绘制，&lt;/li&gt;
&lt;li&gt;等到x轴的坐标大于w或者小于0，改变每一步的正负值，使其反向运动，&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;鼠标进入再鼠标所在位置绘制圆形，然后开始下落&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;时钟案例&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="JS" scheme="https://wangpansheng.github.io/tags/JS/"/>
    
      <category term="画布" scheme="https://wangpansheng.github.io/tags/%E7%94%BB%E5%B8%83/"/>
    
      <category term="Canvas" scheme="https://wangpansheng.github.io/tags/Canvas/"/>
    
  </entry>
  
  <entry>
    <title>Canvas入门1</title>
    <link href="https://wangpansheng.github.io/2016/09/10/canvas%E5%85%A5%E9%97%A81/"/>
    <id>https://wangpansheng.github.io/2016/09/10/canvas入门1/</id>
    <published>2016-09-10T13:22:24.000Z</published>
    <updated>2018-01-31T12:39:09.805Z</updated>
    
    <content type="html"><![CDATA[<ol><li><p>概念：中文：“画布，帆布”<br>HTML5提出一个新的标签。可以通过脚本语言（JS）在其上面绘制图形、图像以及制作动画。</p></li><li><p>基本使用</p></li></ol><ul><li>创建Canvas标签，同时指定canvas标签的大小；如果不指定的话，默认值为 300 * 150 （px）<br> 如果想动态改变canvas的宽和高，必须通过其属性节点width以及height来改变，不能通过css样式来改变。</li><li>通过js获取到canvas对象。本身Canvas不具备绘图能力。</li><li>通过Canvas对象调用getContext方法来获取绘图的API方法</li><li>使用获取到绘图工具来绘制图形</li></ul><ol><li>getContext方法</li></ol><ul><li>语法: <canvas对象>.getContext(‘2d|WebGL’);</canvas对象></li><li>功能：获取绘制平面图形或立体图形的api方法以及相关属性；如果参数值为’2d’<br> ，表示获取绘制平面图形的工具；如果参数值为’WebGL’,表示获取绘制立体图形的工具。</li></ul><ol><li>基本绘图API</li></ol><ul><li>ctx.moveTo(x, y) 移动笔触到指定点。</li><li>ctx.lineTo(x, y) 从笔触所在点连线到指定点</li><li>ctx.stroke(); 将当前路径绘制的图形描绘其边框</li><li>ctx.fill(); 填充一个封闭的图形（将当前路径形成一个封闭图形，然后在填充。）</li><li>stroke方法与fill方法可以同时调用</li></ul><a id="more"></a><ol><li>开启新路径的方法</li></ol><ul><li>ctx.beginPath();</li></ul><ol><li>闭合路径的方法</li></ol><ul><li>ctx.closePath();<br>如果当前路径，没有形成一个封闭的图形，可以调用该方法来将图形闭合。</li><li>注意：beginPath与closePath不需要成对出现</li></ul><ol><li><p>非零环绕原则：是用来判断某一封闭的区域是否要填充。<br>如果想判断指定区域是否填充，就在该区域内选择任意点，然后从该点引出一条射线，穿过整个图形到外部。查看该射线与图形的相交线，如果相交线是顺时针穿出射线，计数 + 1；如果是逆时针穿出射线，计数 -1；如果最后所有计数累加在一起，值不为0就填充该区域;</p><p>如果相交线是自上而下的穿出射线，即为顺时针穿出，计数 +1<br>如果相交线是自下而上的穿出射线，即为逆时针穿出，计数 -1</p></li><li><p>奇偶原则：是用来判断某一封闭的区域是否要填充<br>如果想判断指定区域是否填充，就在该区域内选择任意点，然后从该点引出一条射线，穿过整个图形到外部。查看该射线与图形的相交线的个数。如果为奇数，那么就填充；如果为偶数就不填充。</p></li></ol><h3 id="线性相关属性"><a href="#线性相关属性" class="headerlink" title="线性相关属性"></a>线性相关属性</h3><ol><li>设置线宽</li></ol><ul><li>ctx.lineWidth = value;</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;ol&gt;
&lt;li&gt;&lt;p&gt;概念：中文：“画布，帆布”&lt;br&gt;HTML5提出一个新的标签。可以通过脚本语言（JS）在其上面绘制图形、图像以及制作动画。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;基本使用&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;创建Canvas标签，同时指定canvas标签的大小；如果不指定的话，默认值为 300 * 150 （px）&lt;br&gt; 如果想动态改变canvas的宽和高，必须通过其属性节点width以及height来改变，不能通过css样式来改变。&lt;/li&gt;
&lt;li&gt;通过js获取到canvas对象。本身Canvas不具备绘图能力。&lt;/li&gt;
&lt;li&gt;通过Canvas对象调用getContext方法来获取绘图的API方法&lt;/li&gt;
&lt;li&gt;使用获取到绘图工具来绘制图形&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;getContext方法&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;语法: &lt;canvas对象&gt;.getContext(‘2d|WebGL’);&lt;/canvas对象&gt;&lt;/li&gt;
&lt;li&gt;功能：获取绘制平面图形或立体图形的api方法以及相关属性；如果参数值为’2d’&lt;br&gt; ，表示获取绘制平面图形的工具；如果参数值为’WebGL’,表示获取绘制立体图形的工具。&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;基本绘图API&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;ctx.moveTo(x, y) 移动笔触到指定点。&lt;/li&gt;
&lt;li&gt;ctx.lineTo(x, y) 从笔触所在点连线到指定点&lt;/li&gt;
&lt;li&gt;ctx.stroke(); 将当前路径绘制的图形描绘其边框&lt;/li&gt;
&lt;li&gt;ctx.fill(); 填充一个封闭的图形（将当前路径形成一个封闭图形，然后在填充。）&lt;/li&gt;
&lt;li&gt;stroke方法与fill方法可以同时调用&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="JS" scheme="https://wangpansheng.github.io/tags/JS/"/>
    
      <category term="canvas" scheme="https://wangpansheng.github.io/tags/canvas/"/>
    
      <category term="画布" scheme="https://wangpansheng.github.io/tags/%E7%94%BB%E5%B8%83/"/>
    
  </entry>
  
  <entry>
    <title>关于js中的静态方法和实例方法</title>
    <link href="https://wangpansheng.github.io/2016/08/15/%E5%85%B3%E4%BA%8Ejs%E4%B8%AD%E7%9A%84%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95%E5%92%8C%E5%AE%9E%E4%BE%8B%E6%96%B9%E6%B3%95/"/>
    <id>https://wangpansheng.github.io/2016/08/15/关于js中的静态方法和实例方法/</id>
    <published>2016-08-15T14:29:16.000Z</published>
    <updated>2018-01-31T12:39:09.849Z</updated>
    
    <content type="html"><![CDATA[<ul><li><p>最近有人问我关于什么静态方法和实例方法不是太清除，所以做一个整理。</p></li><li><p>什么是静态方法：</p><blockquote><p>   静态方法是指不需要声明类的实例就可以使用的方法。</p></blockquote></li></ul><p>代码演示<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span> (<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line"><span class="comment">//在foo上直接添加静态方法</span></span><br><span class="line">foo.say = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"我是静态方法，不需要实例化，可以直接用函数调用!"</span>);</span><br><span class="line">&#125;;</span><br><span class="line">foo.say();<span class="comment">//函数直接调用方法say，打印hello</span></span><br></pre></td></tr></table></figure></p><ul><li>什么是实例方法<blockquote><p>   实例方法是指必须要先使用”new”关键字声明一个类的实例, 然后才可以通过此实例访问的方法。</p></blockquote></li></ul><a id="more"></a><p>代码演示：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Fn</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.say = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"我是实例化之后才可以调用的方法！"</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> Fn();<span class="comment">//需要首先实例化</span></span><br><span class="line">obj.say();<span class="comment">//才可以调用</span></span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;&lt;p&gt;最近有人问我关于什么静态方法和实例方法不是太清除，所以做一个整理。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;什么是静态方法：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;   静态方法是指不需要声明类的实例就可以使用的方法。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;代码演示&lt;br&gt;&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;foo&lt;/span&gt; (&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;&amp;#123;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//在foo上直接添加静态方法&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;foo.say = &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;)&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(&lt;span class=&quot;string&quot;&gt;&quot;我是静态方法，不需要实例化，可以直接用函数调用!&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;foo.say();&lt;span class=&quot;comment&quot;&gt;//函数直接调用方法say，打印hello&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;什么是实例方法&lt;blockquote&gt;
&lt;p&gt;   实例方法是指必须要先使用”new”关键字声明一个类的实例, 然后才可以通过此实例访问的方法。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="js" scheme="https://wangpansheng.github.io/tags/js/"/>
    
      <category term="静态方法" scheme="https://wangpansheng.github.io/tags/%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95/"/>
    
      <category term="实例方法" scheme="https://wangpansheng.github.io/tags/%E5%AE%9E%E4%BE%8B%E6%96%B9%E6%B3%95/"/>
    
      <category term="函数" scheme="https://wangpansheng.github.io/tags/%E5%87%BD%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>AngularJS系列之模块化介绍</title>
    <link href="https://wangpansheng.github.io/2016/07/20/AngularJS%E7%B3%BB%E5%88%97%E4%B9%8B%E6%A8%A1%E5%9D%97%E5%8C%96%E4%BB%8B%E7%BB%8D/"/>
    <id>https://wangpansheng.github.io/2016/07/20/AngularJS系列之模块化介绍/</id>
    <published>2016-07-20T05:07:39.000Z</published>
    <updated>2018-01-31T12:39:09.799Z</updated>
    
    <content type="html"><![CDATA[<h2 id="模块化介绍"><a href="#模块化介绍" class="headerlink" title="模块化介绍"></a>模块化介绍</h2><ul><li>通过AngularJS构建应用时，是以模块化的方式组织的，即将整个应用划分成若干个模块，每个模块都各有其职责，最终组合成一个整体。</li><li>采用模块化的组织方式，可以最大程度的实现代码的复用，可以像搭积木一样进行开发。</li></ul><h2 id="定义应用"><a href="#定义应用" class="headerlink" title="定义应用"></a>定义应用</h2><ul><li><p>通过为任一HTML标签添加ng-app属性，可以指定一个应用，表示此标签所包裹的内容都属于应用的一部分。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--为html标签添加ng-app表明整个文档都是应用--&gt;</span><br><span class="line">&lt;!--ng-app属性可以不赋值，但是要关联相应模块时则必须赋值--&gt;</span><br><span class="line">&lt;html lang=&quot;zh-CN&quot; ng-app=&quot;App&quot;&gt;&lt;/html&gt;</span><br></pre></td></tr></table></figure></li></ul><h2 id="定义模块"><a href="#定义模块" class="headerlink" title="定义模块"></a>定义模块</h2><ul><li><p>AngularJS提供了一个全局对象angular，在此全局对象下存在若干方法，其中angular.module()方法用来定义一个模块。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//通过module方法定义模块</span></span><br><span class="line"><span class="comment">//需要传递两个参数，第一个表示模块的名字，</span></span><br><span class="line"><span class="comment">// 第二个表示此模块依赖的其它模块</span></span><br><span class="line"><span class="keyword">var</span> app = angular.module(<span class="string">"app"</span>,[]);</span><br></pre></td></tr></table></figure><p>注：应用本质也是一个模块（一个比较大的模块）；</p></li></ul><h2 id="定义控制器"><a href="#定义控制器" class="headerlink" title="定义控制器"></a>定义控制器</h2><a id="more"></a><ul><li><p>控制器（Controller）作为连接模型（model）和视图（view）的桥梁存在，所以当我们定义好了控制器以后，也就定义好了模型和视图。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//app是一个模型实例对象</span></span><br><span class="line"><span class="comment">//通过这个实例对象定义控制器，需要两个参数</span></span><br><span class="line"><span class="comment">//第一个参数表示控制器名称，</span></span><br><span class="line"><span class="comment">//第二个参数是一个数组，这个数组除最后一个单元是函数外，其余都是字符串，标明此控制器的依赖关系</span></span><br><span class="line">app.controller(<span class="string">'studentController'</span>,[<span class="string">'$scope'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">$scope</span>) </span>&#123;</span><br><span class="line">  <span class="comment">//模型（model）</span></span><br><span class="line">  $scope = [</span><br><span class="line">    &#123;<span class="attr">name</span>: <span class="string">"李白"</span>, <span class="attr">sex</span>: <span class="string">'男'</span>, <span class="attr">age</span>: <span class="string">"23"</span>&#125;,</span><br><span class="line">    &#123;<span class="attr">name</span>: <span class="string">'华仔'</span>, <span class="attr">sex</span>: <span class="string">'男'</span>, <span class="attr">age</span>: <span class="string">'34'</span>&#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;])</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>模型数据时要展示到视图上的，所以需要将控制器关联到视图上，通过为HTML标签添加ng-controller属性并赋值相应的控制器的名称，就确立了关联关系，</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--添加ng-controller属性，并赋值为相应的控制器名称--&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">table</span> <span class="attr">ng-controller</span>=<span class="string">"StudentController"</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">th</span>&gt;</span>姓名<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">th</span>&gt;</span>性别<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">th</span>&gt;</span>年龄<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">tr</span> <span class="attr">ng-repeat</span>=<span class="string">"student in students"</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">td</span>&gt;</span>&#123;&#123;student.name&#125;&#125;<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">td</span>&gt;</span>&#123;&#123;student.sex&#125;&#125;<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">td</span>&gt;</span>&#123;&#123;student.age&#125;&#125;<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>以上为AngularJS最基本的MVC工作模式。</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;模块化介绍&quot;&gt;&lt;a href=&quot;#模块化介绍&quot; class=&quot;headerlink&quot; title=&quot;模块化介绍&quot;&gt;&lt;/a&gt;模块化介绍&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;通过AngularJS构建应用时，是以模块化的方式组织的，即将整个应用划分成若干个模块，每个模块都各有其职责，最终组合成一个整体。&lt;/li&gt;
&lt;li&gt;采用模块化的组织方式，可以最大程度的实现代码的复用，可以像搭积木一样进行开发。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;定义应用&quot;&gt;&lt;a href=&quot;#定义应用&quot; class=&quot;headerlink&quot; title=&quot;定义应用&quot;&gt;&lt;/a&gt;定义应用&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;通过为任一HTML标签添加ng-app属性，可以指定一个应用，表示此标签所包裹的内容都属于应用的一部分。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&amp;lt;!--为html标签添加ng-app表明整个文档都是应用--&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;lt;!--ng-app属性可以不赋值，但是要关联相应模块时则必须赋值--&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;lt;html lang=&amp;quot;zh-CN&amp;quot; ng-app=&amp;quot;App&amp;quot;&amp;gt;&amp;lt;/html&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;定义模块&quot;&gt;&lt;a href=&quot;#定义模块&quot; class=&quot;headerlink&quot; title=&quot;定义模块&quot;&gt;&lt;/a&gt;定义模块&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;AngularJS提供了一个全局对象angular，在此全局对象下存在若干方法，其中angular.module()方法用来定义一个模块。&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//通过module方法定义模块&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//需要传递两个参数，第一个表示模块的名字，&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 第二个表示此模块依赖的其它模块&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; app = angular.module(&lt;span class=&quot;string&quot;&gt;&quot;app&quot;&lt;/span&gt;,[]);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;注：应用本质也是一个模块（一个比较大的模块）；&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;定义控制器&quot;&gt;&lt;a href=&quot;#定义控制器&quot; class=&quot;headerlink&quot; title=&quot;定义控制器&quot;&gt;&lt;/a&gt;定义控制器&lt;/h2&gt;
    
    </summary>
    
    
  </entry>
  
</feed>
