[{"title":"ubuntu安装rime输入法","date":"2018-04-13T09:46:19.000Z","path":"2018/04/13/ubuntu安装rime输入法/","text":"ubuntu系统安装 rime输入法 RIME／中州韻輸入法引擎，是一個跨平臺的輸入法算法框架。基於這一框架，Rime 開發者與其他開源社區的參與者在 Windows、macOS、Linux、Android 等平臺上創造了不同的輸入法前端實現 以上是RIME官网的介绍，是一款开源的跨平台输入法。这里是linux平台的，Windows平台下的是小狼毫，都很好用。 因为系统自带的输入法，不是很好用，而且以前一直用的rime输入法，确实很好用，但是，由于之前没怎么用ubuntu，今天安装，遇到了一些问题，这里记录下 首先 安装 ibus-rime,执行下面命令 1sudo apt-get install ibus-rime 然后 安装输入方案，选择自己需要的安装 12345678910111213141516171819202122# 朙月拼音（預裝）sudo apt-get install librime-data-luna-pinyin# 雙拼sudo apt-get install librime-data-double-pinyin# 宮保拼音sudo apt-get install librime-data-combo-pinyin# 注音、地球拼音sudo apt-get install librime-data-terra-pinyin librime-data-bopomofo# 倉頡五代（預裝）sudo apt-get install librime-data-cangjie5# 速成五代sudo apt-get install librime-data-quick5# 五筆86、袖珍簡化字拼音、五筆畫sudo apt-get install librime-data-wubi librime-data-pinyin-simp librime-data-stroke-simp# IPA (X-SAMPA)sudo apt-get install librime-data-ipa-xsampa# 上海吳語sudo apt-get install librime-data-wugniu# 粵拼sudo apt-get install librime-data-jyutping# 中古漢語拼音sudo apt-get install librime-data-zyenpheng 但是安装之后，直接切换输入法的时候，是找不到rime，是需要先去系统设置-&gt;语言支持-&gt;键盘输入法系统，把默认值fcitx设置为IBus，然后再设置，如果不行就重启系统试试 rime的设置文件放在~/.config/ibus/rime下的default.yaml，执行vi default.yaml，编辑文件，把需要用的方案写在schema_list中，然后重新部署，再按ctrl+`或者F4，就可以切换方案了， 123schema_list: - schema: wubi_pinyin - schema: wubi86","tags":[{"name":"linux","slug":"linux","permalink":"https://wangpansheng.github.io/tags/linux/"},{"name":"ubuntu","slug":"ubuntu","permalink":"https://wangpansheng.github.io/tags/ubuntu/"},{"name":"rime","slug":"rime","permalink":"https://wangpansheng.github.io/tags/rime/"}]},{"title":"快速上手快应用","date":"2018-03-23T03:19:27.000Z","path":"2018/03/23/快速上手快应用/","text":"快应用是国内各大厂商联合制定的，基于手机硬件平台的新型应用形态，和小程序类似，无需安装，随用随走。 搭建开发环境 首先需要安装nodejs版本6.0以上，不过官方建议不要使用8.0.*版本，会有报错. 安装hap-toolkit 通过npm安装 1npm i -g hap-toolkit 输入以下命令，检测安装是否成功1hap -V 创建第一个项目 环境搭建好之后，直接输入下面命令，可以初始化我们的第一个快应用 1hap init &lt;projectName&gt; 目录的简要说明如下： src：项目源文件夹 node_modules：项目的依赖类库 sign：签名模块，当前仅有debug签名，如果内测上线，请添加release文件夹，增加线上签名；签名生成方法请参考文档：编译工具的openssl 编译项目安装依赖,在项目根目录输入命令安装依赖，可以使用npm或者yarn123npm i 或者yarn 编译项目，在项目根目录，进行编译打包，生成rpk包1npm run build 编译打包之后，项目根目录下会生成文件夹 build,dist build: 临时产出，包含编译后的页面js，图片等 dist: 最终产出，包含rpk文件。其实是将build目录下的资源打包压缩为一个文件，后缀名为rpk，这个rpk文件就是项目编译后的最终产出","tags":[]},{"title":"科学上网","date":"2017-10-31T08:02:12.000Z","path":"2017/10/31/手摸手搭建科学上网去服务/","text":"因为工作的原因，需要查询资料，国内文档比较少，需要访问国外的网站，所以这里需要科学上网。本篇文章是搭建科学上网的服务端，搭建成功之后，客户端链接就可以尽情科学上网了。 安装具体步骤 首先，你需要有一台海外的服务器，然后才能执行搭建服务。 我这里用的是Ubuntu系统，步骤非常简单，一步一步执行下面的命令就好 12345sudo apt-get update&lt;!-- 如果服务器没有安装git，需要执行这一步，安装git --&gt;sudo apt-get install gitsudo apt-get install python-pippip install git+https://github.com/shadowsocks/shadowsocks.git@master 启动服务直接启动12ssserver -c /etc/shadowsocks.json&lt;!-- 启动之后，ctrl+c就可以关闭服务 --&gt; 后台使用 在后台启动服务 12ssserver -c /etc/shadowsocks.json -d startssserver -c /etc/shadowsocks.json -d stop 至此，服务端已经搭建完成，直接在客户端链接就可以科学上网了。","tags":[]},{"title":"MongoDB数据库配合NodeJS简单使用","date":"2017-10-09T11:11:15.000Z","path":"2017/10/09/MongoDB简单学习/","text":"关于 MongoDB 我们一般把数据库分为关系型数据库和非关系型数据库，MongoDB就是属于非关系型数据库的一种。 官网：https://www.mongodb.com/ 下载地址：https://www.mongodb.com/download-center?jmp=nav 环境安装 https://www.smartftp.com/support/kb/the-program-cant-start-because-api-ms-win-crt-runtime-l1-1-0dll-is-missing-f2702.html?lang=zh-CN http://stackoverflow.com/questions/33265663/api-ms-win-crt-runtime-l1-1-0-dll-is-missing-when-opening-microsoft-office-file 启动和关闭 MongoDB 数据库服务程序mongod.exe 是我们要启动的服务器文件mongo的客户端去连我们的服务器 打开终端，输入 mongod 回车 mongod 命令用来启动 MongoDB 数据服务 MongoDB 服务默认将 C:/data/db 目录作为数据目录 所以你需要先在 C:/ 根目录新建一个目录：C:/data/db 当你执行 mongod 命令的时候，默认会去使用 c:/data/db 目录作为数据存储目录 如果你不想使用 c:/data/db 目录 mongod –dbpath=路径 32位操作系统启动 MongoDB http://jingyan.baidu.com/article/76a7e409e1bb49fc3b6e1516.html mongod --dbpath 数据存储路径 --journal --storageEngine=mmapv1mongod –dbpath C:/data/db –journal –storageEngine=mmapv1` 基础概念数据库 什么是数据？ 数据是信息的表现形式和载体，可以是符号、文字、数字、语音、图像、视频等。通俗一点，数据就是信息，例如，个人信息、账户信息、家庭信息、企业信息、财务信息等等。 什么是数据库（Database，DB）？ 数据库是按照数据结构来组织、存储和管理数据的仓库。 为什么要使用数据库？ 我们需要使用数据库来存储我们网站的数据，然后通过增删改查进行数据交互，数据库，为我们提供了存储数据的仓库。 什么是数据库管理系统（DataBase Management System，DBMS）？ 数据库管理系统（DataBase Management System，DBMS）是为管理数据库而设计的大型电脑软件管理系统.例如，Oracle、Microsoft SQL Server、Access、MySQL、PostgreSQL、db2等等.我们可以简称这些数据库管理系统为数据库，虽然这种叫法不是很严谨，但是一般人都听的懂。 数据库的分类 关系型数据库 sql语言 关系数据库管理系统(Relational Database Management System)，是将数据组织为相关的行和列的系统，而管理关系数据库的计算机软件就是关系数据库管理系统，常用的数据库软件有Oracle、SQL Server、MySQL等。 非关系型数据库 nosql 内存数据库 redis 面向文档数据库 mongodb 文档 document 文档是MongoDB中最基本的单元，里边包含多个键值对。 12&#123;name:\"zhangsan\",age:12&#125;&#123;name:\"lisi\"&#125; 集合 collection 集合就是一组文档，特点是动态模式，集合中每一个文档都有可能不一样。但是在实际开发中，最好我们保存一样格式的文档。 常用指令1. 列出所有的数据库1show dbs 2. 进入或者新建数据库user123use user//如果已经有了user数据库，就会进入user数据库//如果没有user数据库，就会自动新建数据库，如果数据库中没有任何文档，则用show dbs不会显示该仓库 3. 新建文档12db.user.insert(&#123;name:\"wang\"&#125;)//在user集合中添加一条文档数据 4. 查看user集合中的文档1db.user.find() 5. 更新文档内容1db.user.update(&#123;name:\"wang\"&#125;,&#123;$set:&#123;name:\"ang\"&#125;&#125;) 6. 删除文档12db.user.remove(&#123;name:\"wang\"&#125;)//如果不传入参数，则会直接删除集合 7. 删除数据库12use userdb.dropDatabase() js链接MongoDb mongodb包提供的方法api和monggodb的命令基本一样，我们可以在nodejs中使用mongodb数据库进行增删改查操作。 api地址：http://mongodb.github.io/node-mongodb-native/2.2/api","tags":[{"name":"MongoDB","slug":"MongoDB","permalink":"https://wangpansheng.github.io/tags/MongoDB/"},{"name":"NodeJS","slug":"NodeJS","permalink":"https://wangpansheng.github.io/tags/NodeJS/"}]},{"title":"linux安装mongodb","date":"2017-09-26T12:26:22.000Z","path":"2017/09/26/linux安装mongodb/","text":"Linux下安装MongoDB一、MongoDB的安装 下载安装包 1234# - 下载方式：curl -O https://fastdl.mongodb.org/linux/mongodb-linux-x86_64-3.6.4.tgz# - 解压缩压缩包：tar zxvf mongodb-linux-x86_64-3.6.4.tgz 安装准备 创建数据库文件夹与日志文件、配置文件： 123mkdir -p /usr/local/server/mongodb/datatouch /usr/local/server/mongodb/mongod.logtouch /usr/local/server/mongodb/mongodb.conf 将mongodb移动到/usr/local/server/mongdb文件夹： 1mv mongodb-linux-x86_64-3.6.4/* /usr/local/server/mongodb 启动mongodb(有两种方式) 参数启动： 12# 参数启动可以直接在命令后面加配置参数，也可以加配置文件启动，如下加配置参数启动：./mongod --dbpath=/usr/local/server/mongodb/data --logpath=/usr/local/server/mongodb/mongod.log --logappend --port=27017 --fork 如果在配置文件中配置好各项参数，则可以使用配置文件启动： 12./mongod --config /usr/local/server/mongodb/mongodb.confmongod -f mongodb.conf mongodb.conf 1234567dbpath=/usr/local/server/mongodb/data #数据库路径logpath=/usr/local/server/mongodb/mongodb.log #日志输出文件路径logappend=true #错误日志采用追加模式，配置这个选项后mongodb的日志会追加到现有的日志文件，而不是从新创建一个新文件journal=true #启用日志文件，默认启用quiet=true #这个选项可以过滤掉一些无用的日志信息，若需要调试使用请设置为falseport=27017 #端口号 默认为27017 加入系统路径变量注：可以将mongodb临时加入系统路径变量中，这样可以不用输入路径直接启动，代码如下：export PATH=/usr/local/server/mongodb/bin:$PATH然后可以查看是否成功：echo $PATH 二、用户授权和管理 mongodb安装好后第一次进入是不需要密码的，也没有任何用户，通过shell命令可直接进入，cd到mongodb目录下的bin文件夹，执行命令./mongo即可 12345[root@namenode mongodb]# ./bin/mongoMongoDB shell version: 1.8.2connecting to: test&gt; use test;switched to db test 添加管理用户（mongoDB 没有无敌用户root，只有能管理用户的用户 userAdminAnyDatabase）, 12&gt;use admin&gt;db.createUser( &#123;user: \"admin\",pwd: \"123456\",roles: [ &#123; role: \"userAdminAnyDatabase\", db: \"admin\" &#125; ]&#125;) 注：添加完用户后可以使用show users或db.system.users.find()查看已有用户 添加完管理用户后，关闭MongoDB，并使用权限方式再次开启MongoDB，这里注意不要使用kill直接去杀掉mongodb进程，（如果这样做了，请去data/db目录下删除mongo.lock文件），可以使用db.shutdownServer()关闭 使用权限方式启动MongoDB 1234./mongod --dbpath=/usr/local/server/mongodb/data --logpath=/usr/local/server/mongodb/mongod.log --fork --auth或者在配置文件中修改： auth = true#noauth = true 进入mongo shell，使用admin数据库并进行验证，如果不验证，是做不了任何操作的。 12&gt; use admin&gt; db.auth(\"admin\",\"123456\") #认证，返回1表示成功 验证之后还是做不了操作，因为admin只有用户管理权限，下面创建用户，用户都跟着库走， 12&gt; use mydb&gt; db.createUser(&#123;user: \"root\",pwd: \"123456\",roles: [&#123; role: \"readWrite\", db: \"mydb\" &#125;]&#125;) 使用创建的用户root登录进行数据库操作： 123456789[root@localhost mongodb]# mongo 127.0.0.1/mydb -uroot -pMongoDB shell version: 3.2.9Enter password:connecting to: 127.0.0.1/mydb&gt; dbmydb&gt; use mydbswitched to db mydb&gt; show collections 然后就可以进行增删改查各种数据操作…","tags":[{"name":"linux","slug":"linux","permalink":"https://wangpansheng.github.io/tags/linux/"},{"name":"mongodb","slug":"mongodb","permalink":"https://wangpansheng.github.io/tags/mongodb/"}]},{"title":"css变形","date":"2017-07-11T01:23:13.000Z","path":"2017/07/11/css变形/","text":"css变形 我们可以借助css3实现图片元素的倾斜、缩放、移动、以及翻转效果。 1. tranfrom属性语法 tranfrom属性让元素在一个坐标系统中变形，包含一系列变形函数，可以移动、旋转和缩放元素。 1transfrom: none | &lt;transfrom-function&gt; 默认值为:none,表示不对元素进行变形; 也可以指定一个或者多个变形函数，以空格分开。如：rotate、scale、trasnslate; 2. 变形函数介绍 所有的2D变形函数可以应用于3D变形规范中。 函数 | 功能描述 ----|------- translate() | 移动元素，可以根据X轴和Y轴坐标重新定位自己的位置，有tranlateX(),translateY() scale() | 缩小或者方法元素，可以使元素尺寸发生变化，有scaleX()和scaleY() rotate() | 旋转元素 skew() | 让元素倾斜，在此基础上有两个扩展函数，skewX()和skewY() matrix()|定义矩阵变形，基于X轴和Y轴坐标重新定位元素位置","tags":[{"name":"css3","slug":"css3","permalink":"https://wangpansheng.github.io/tags/css3/"}]},{"title":"前后端渲染的对比","date":"2017-05-14T11:01:13.000Z","path":"2017/05/14/前后端渲染的对比/","text":"服务端渲染是通过后端模板引擎编译成html,css,js,然后回传给前端来进行显示；而前端渲染则是将整个生成逻辑代码全部回传前端，再由客户端生成用户界面。 为什么会有服务端渲染与客户端渲染早期，我们每一个页面都是直接由html，css，js实现的，每一个页面彼此之间相当于是独立的，当我们的网站应用足够大的时候，每当我们需要修改网站的内容时，我们需要更改很多的代码，非常麻烦。 那么后来，我们聪明的程序员就想到了，使用代码生成代码，就是后端的模板引擎，人们开始广泛使用模板代替手写html，大大减少的前端的工作量。通过代码生成代码，其实就是编译，基于html等基础语言，做出了更高层次的抽象封装，增加了易用性。 后来h5,c3的崛起，再加上客户端硬件性能的提升，我们开始通过前端模板引擎，来在客户端渲染页面。 对待模板，angular，vue，react的态度都不一样。 前后端真正解耦，前端专注于UI视图,后台专注于数据处理，通过设计好的api交互，这是未来的趋势。 从 后端渲染 到 前端渲染 ，有什么变化 计算任务的变化 原来由后端执行的渲染任务，现在放在了前端来做，降低了多用户同时访问时服务端的压力，然后端专注做后端的事情，由于客户端硬件的发展，前端处理起来没有什么问题。 放弃前端权限 将整个页面逻辑，交给客户端以后，会出现劫持的情况，比如某些运营商劫持之后，投放广告。俗话说的好一切在前端谈安全都是耍流氓，后端不能轻信前端发来的数据，一切数据都需要过滤与验证，最好使用ssl，屏蔽XSS。 结语总之一句话，后端渲染针对seo比较友好，前端渲染，可以减轻服务端的压力，提升服务器的性能，而且可以实现前后端分离！","tags":[{"name":"服务端渲染","slug":"服务端渲染","permalink":"https://wangpansheng.github.io/tags/服务端渲染/"}]},{"title":"ubuntu常用软件部署","date":"2017-04-02T09:46:19.000Z","path":"2017/04/02/ubuntu常用软件部署/","text":"ubuntu中快速安装nodejs1. 我们可以直接通过apt-get安装nodejs123sudo apt-get update //需要先刷新本地索引包sudo apt-get install nodejs //然后安装nodejs包sudo apt-get install npm //安装npm包管理器 2. 安装好的node版本较低，我们可以使用n模块升级node到你需要打版本1. node有一个 n模块，专门用来管理nodejs版本的。不过目前并不支持windows系统。我们先安装下1npm install -g n 2. 升级到制定版本，我们可以在n加上指定的版本号就可以1sudo n 6.10.2 3. 还有一些常用打快捷方法123sudo n latest //安装最新打官方版本sudo n stanle //安装最新打稳定版sudo n lts //安装最新打lts官方版 4. 删除版本12sudo n rm 0.9.4sudo n -0.9.4 更多命令，我们可以使用n --help寻求帮助 ubuntu常用工具安装右上角任务栏显示cpu内存使用百分比，还可以显示网络传输速率123456sudo add-apt-repository ppa:fossfreedom/indicator-sysmonitor //这里选择按enter键sudo apt-get updatesudo apt-get install indicator-sysmonitor//启动indicator-sysmonitor &amp;//ctrl+c后台运行该程序 启动之后，最好让程序开机自启动，鼠标右键点击标题栏上图标，弹出菜单，把run on startup后边打勾打上，然后进去advanced选项卡，就可以自定义配置需要显示在任务栏的项目啦 安装git123sudo apt-get install gitgit config --global user.name &quot;name&quot;git config --global user.email &quot;your@email.com&quot; 安装编译工具1sudo apt-get install build-essential 安装yarn包管理工具1sudo npm install -g yarn 安装cnpm镜像源 下载包直接可以使用 cnpm install name 下载 1sudo npm install -g cnpm 安装nrm，node下载数据源管理器12sudo npm install -g nrmnrm -v //查看安装版本验证是否安装成功 可以查看当前所有的下载数据源链接1nrm ls 测试所有打镜像源的响应速度，然后根据测试我们可以切换我们需要使用的下载源12nrm testnrm use [taobao] github使用ssh 我们使用git去github上传东西，一般都使用ssh免密方式，所以需要首先生成一枚ssh-key密钥，然后在home文件夹进入个人文件夹中，按ctrl+h，会显示所有隐藏文件，打开.ssh文件夹中的id_rsa.pub文件，把里边内容粘贴到github上就可以啦 1ssh-keygen -t rsa -b 4096 -C &quot;wangpansheng@qq.com&quot;","tags":[{"name":"linux","slug":"linux","permalink":"https://wangpansheng.github.io/tags/linux/"},{"name":"ubuntu","slug":"ubuntu","permalink":"https://wangpansheng.github.io/tags/ubuntu/"}]},{"title":"ubuntu常见问题处理","date":"2017-04-02T09:46:19.000Z","path":"2017/04/02/ubuntu常见问题/","text":"常见问题处理1. win10和ubuntu双系统时，硬盘无法加载问题 需要依赖于ntfs-3g，如果没有需要先安装这个 1sudo apt-get install ntfs-3g 然后只用ntfsfix修复，即可 1sudo ntfsfix /绝对路径 常用软件推荐1. 图片处理:GIMP 对于非专业性的图片处理，该款APP已经十分足够了，功能也挺丰富、强大的。 2. 视频播放：VLC 能够播放rmvb、mp4、avi等多种格式的视频文件，支持快速播放等功能。 安装123$ sudo add-apt-repository ppa:videolan/stable-daily$ sudo apt-get update$ sudo apt-get install vlc 3. 启动栏：Docky ndicator-sysmonitor 这是一款能够实时查看当前系统的CPU、内存、网络、IP等信息","tags":[{"name":"linux","slug":"linux","permalink":"https://wangpansheng.github.io/tags/linux/"},{"name":"ubuntu","slug":"ubuntu","permalink":"https://wangpansheng.github.io/tags/ubuntu/"}]},{"title":"centos-01","date":"2017-03-03T07:44:10.000Z","path":"2017/03/03/centos-01/","text":"常用命令123456//查看当前centos系统的版本cat /etc/redhat-release//查看系统内核版本是32位还是64位uname -r//安装cnpmnpm install cnpm -g --registry=https://registry.npm.taobao.org 添加用户 在企业生产中，一般不会直接使用root来操作，可以通过命令创建用户，并且进行切换，普通用户下，前边显示的是$符号，root下显示的是# 12345useradd username //添加用户名passwd username //给刚才添加的用户，设置密码，然后会提示输入密码，输入两次就可以了su - username //可以切换到指定的用户su - root //可以切换到rootwhoami //可以查看当前用户是谁","tags":[{"name":"centos","slug":"centos","permalink":"https://wangpansheng.github.io/tags/centos/"}]},{"title":"NodeJS构建express框架开发简单应用","date":"2017-01-10T13:39:28.000Z","path":"2017/01/10/nodeJS构建express框架开发简单应用/","text":"使用node express简单构建，配合MongoDB数据库，实现简单的增删改查操作 首先我们需要构建express本地框架结构12express demo//在demo文件夹中构建express结构 然后我们运行一下，1npm start 执行之后，我们在浏览器打开localhost:3000就可以看到初始化的页面， 因为我们是使用 MongoDb数据库，所以需要安装mongodb的nodeJS包，mongodb包的api基本上mongodb数据库的命令行操作命令差不多，所以，如果你比较清楚命令行操作命令，使用起来就会非常方便，1234//安装mongodb包npm install mongodb --save//安装依赖包npm install 至此，所有的准备工作基本完成，当然，前提你已经装好mongodb数据库，而且在使用的时候，需要全程开启数据库服务器。mongodb数据库的安装，我以前有文章有介绍过，有兴趣的可以去看看。 我们使用MVC架构来实现针对数据库的增删改查， 我们创建一个文件夹 module，就是连接控制数据库的文件。 我们使用routes来代替controller同样的功能，来连接视图层和数据库的连接。 我们的整体逻辑是，我们路由中添加一个get请求，请求中调用module中的一个操作方法，然后module中的添加方法，再去调用数据库连接，然后在使用操作api操作数据库。在module中首先连接到数据库 1234567891011121314//得到MongoClient对象var MongoClient = require(\"mongodb\").MongoClient;var url = \"数据库主机ip:port/数据库名\"module.exports = function(callback)&#123; MongoClient.connect(url,function(err,db)&#123; if(err)&#123; //代表连接失败 return callback(err); &#125; callback(null,db) &#125;)&#125;","tags":[{"name":"NodeJS express","slug":"NodeJS-express","permalink":"https://wangpansheng.github.io/tags/NodeJS-express/"}]},{"title":"数组方法梳理","date":"2016-11-26T00:55:03.000Z","path":"2016/11/26/数组方法梳理/","text":"由于发现对数组和字符串原生的方法有点记不太清了，所以打算梳理一下，把这写方法整理一下，加强自己的记忆。 以下数组演示都以数组 数组arr=[1,2,3]为原始值； length 返回数组的长度 1arr.length;//返回值是3 concat() 连接两个或更多数组，并返回新数组， 123arr.concat([8,9,0]);//返回是数组[1,2,3,8,9,0]//不会修改原数组 join() 把数组的所有元素放进一个新的字符串，元素根据指定的字符串分割 12arr.join(\"\");//返回值是字符串123 pop() 删除并返回最后一个元素 1234arr.pop();//从数组中删除最后一个元素//返回值是删除的元素，//原数组被更改 push() 向数组最后添加一个或多个元素，并返回添加之后数组的长度1234567arr.push(3);//返回值是新数组长度//原数组被更改arr.push([1,2,3]);//这样调用，会把传入的数组当作数组一个元素arr.push(1,2,4);//会把传入的值按照先后顺序放在数组的最后 reverse() 颠倒数组中元素的排序 12arr.reverse();//返回值和原数组都是反转之后的数组 shift() 删除并返回数组的第一个元素 123arr.shift();//返回被删除的元素//会修改原数组 unshift() 在数组最前添加一个或多个元素，返回新长度1234arr.unshift([2,3,4]);arr.unshift(2,4,4);//如果传入多个元素，传入的第一个元素会在数组的索引0上，第二个会在1上，以此类推，//简单理解，传入多个元素，直接把传入的内容直接放在最前边； slice() 选取并返回数组中指定的元素 12345arr.slice(start,end);//strat是开始索引值，end是结束索引值，不包含end索引的值//如果索引值是负数，-1就是最后一个元素，以此类推//如果没有第二个值，那么从start开始截取到数组结束//不会修改原元素 sort() 对数组的元素进行排序,直接对原数组进行排序，返回值也是排序后的新数组,如果不传参数，则是按照元素首字母排序，如果需要按照指定的规则排序，需要传入指定的函数 1arr.sort(); splice() 从数组中添加删除元素，返回被删除的元素 12345arr.splice(index,howmany,item1...itemx); //index 添加或删除元素的索引位置//howmany 要删除元素的个数，不删除可以设置为0//item 要添加的元素//返回值是删除的元素 toSource() 返回对象的源代码,只有火狐支持 toString() 把数组转换为字符串，并返回结果","tags":[{"name":"数组，js基础","slug":"数组，js基础","permalink":"https://wangpansheng.github.io/tags/数组，js基础/"}]},{"title":"原生框架封装之插件开发","date":"2016-11-20T01:25:49.000Z","path":"2016/11/20/原生框架封装之插件开发/","text":"cookie 历史背景 http https: 都是一种无状态、无连接的协议 tcp/ip 是一种长连接协议 无论什么用户都可以访问网址页面，在实际开发中，有些页面需要先验证身份才可以访问的，此时就需要http记录用户的状态，（登录状态）， 但是http协议是无状态的，因此就诞生了session和cookie 应用场景 登录功能：记录登录状态，以及一些用户基本信息。 用户基本信息：昵称、头像地址、加密后的密码（记住密码）、用户名 做cookie插件的目的 方便前端人员操作cookie 原生js操作cookie 获取 1document.cookie 操作 1document.cookie = \"username=guoguo\"; 设置有效期 默认如果没有设置cookie有效期，它就是一个会话的cookie，也就是说，当浏览器关闭时，该cookie的信息会被清除掉 在设置cookie有效期时，单位是天，在原生设置cookie有效期时，要给expiries赋值为截止日期； 设置域名 1domain=\"xxx.com\" 设置路径 1path=\"/\"","tags":[{"name":"原生框架封装","slug":"原生框架封装","permalink":"https://wangpansheng.github.io/tags/原生框架封装/"},{"name":"js，jquery","slug":"js，jquery","permalink":"https://wangpansheng.github.io/tags/js，jquery/"}]},{"title":"jqeury框架封装练习3","date":"2016-11-18T03:23:09.000Z","path":"2016/11/18/框架封装练习3/","text":"DOM操作模块appendTO方法 语法：实例对象.appendTo(target); 功能：将调用者上的所有DOM元素，分别追加到目标元素上 target参数类型： 选择器 DOM元素 DOM数组，伪数组 为了更方便处理不同的类型，在实现时，首先统一target的参数类型，方便发i吗逻辑的处理 将target统一成itcast的对象，参数一致，便于处理，同时由于是itcast对象，就可以直接调用each方法进行遍历元素 实现思路 统一target类型， 遍历target，再遍历调用者 判断，当目标元素是不是第一个元素，如果是，不需要拷贝源节点，否则就要深拷贝源节点， 将上述得到的新节点，缓存起来到数组中， 再将新节点追加到dom元素中 将缓存的数组转换成itcast对象，作为appendTo的返回值，来实现链式编程。 append方法 功能： 将传入参数追加给调用者。 思路： 将传入实参转换成itcast对象 用传入的实参调用appendTo方法，将this作为目标元素传入appendTo方法 实现链式编程","tags":[{"name":"原生框架","slug":"原生框架","permalink":"https://wangpansheng.github.io/tags/原生框架/"},{"name":"JavaScript","slug":"JavaScript","permalink":"https://wangpansheng.github.io/tags/JavaScript/"}]},{"title":"框架封装之Ajax","date":"2016-11-17T01:31:26.000Z","path":"2016/11/17/框架封装之Ajax/","text":"ajax请求步骤 创建请求对象 格式化数据 与服务器建立连接 监听请求状态 发送请求 创建请求对象 原生方法 w3c:XMLHttpRequest IE：ActiveXObject 封装Ajax模块 确定Ajax配置的默认值 url =&gt; “” type =&gt; “get” data =&gt; {} success =&gt; null fail =&gt; null async =&gt; true dataType =&gt; “json” contentType =&gt; “application/x-www-form-ulencoded” ajax默认配置放在哪？ 要用一个对象来存储上述Ajax配置信息，像jQuery一样，将其放到工厂函数上；放在工厂函数jq上 改造extend方法 如果只传入一个参数，给this扩展成员， 或者传入两个以上，就是给第一个参数扩展成员，， 跨域 jsonp跨域的一种方式，缺点：只能发送跨域get请求 本质：利用script标签的src属性可以跨域的特性 实现流程： 创建script标签，添加到head下 常见一个全局函数，用来处理服务器响应的数据 指定script标签src的属性值，同时将全局函数发送到服务区 要与后台人员沟通，将发送全局函数的参数名告诉后台人员 实现步骤： 常见请求对象，script标签 格式化数据 创建一个全局函数，将函数添加到data内， 监听请求的状态-》使用timeout来做请求状态的监听，如果在超过时间内，表示成功，否则就报超时， 发送请求，-》给script标签指定src属性值","tags":[{"name":"框架封装，ajax","slug":"框架封装，ajax","permalink":"https://wangpansheng.github.io/tags/框架封装，ajax/"}]},{"title":"原生框架封装练习02","date":"2016-11-17T01:26:35.000Z","path":"2016/11/17/原生框架封装练习2/","text":"工具类方法与功能类方法 工具类方法： 可以在内部使用，也可以给使用者使用，不需要常见实例就可以调用的 功能类方法： 框架内部的对象的方法，必须使用该对象去调用，操作dom元素的方法 类型判断方法 isString方法：判断指定 参数是不是字符串类型， isHTML：判断指定参数是不是html字符串 以&lt;开头，以&gt;结尾，长度不小于3的字符串 isDOM：判断指定的参数是不是dom对象 如果参数不为null或undefined，并且具有nodetype属性，那么类型就是dom对象 isArrayLink：判断指定参数是不是数组或伪数组 如果对象的length属性是number类型 isFunction： iswindow：判断指定参数是不是window 如果参数值不是null undefined，并具有window属性指向自己，那么该对象就是window 工具类方法 type方法： ParseHTML方法：将html字符串转换为对应的元素节点 selector参数类型与逻辑保持itcast对象是伪数组 在itcast的原型上添加length=0；表示itcast对象默认的属相为0； 功能类方法toArray 功能：将itcast对象，转换成真数组 实现思路：借调数组的slice方法， 功能类get方法 语法：itcast对象.get( index ) 功能：根据索引获取指定的dom元素 实现思路： 判断index是不是null undefined值，如果是就返回一个数组，存储itcast对象所有的dom元素 判断index是否小于0，是 就index+this.length转换成自然数索引值， 返回this[index] 鸭子类型Ducking Type 如果一个东西，走路像鸭子，声音像鸭子，那么它就是鸭子。 实现伪数组对象，在控制台显示时是以数组形式显示","tags":[{"name":"原生框架封装","slug":"原生框架封装","permalink":"https://wangpansheng.github.io/tags/原生框架封装/"},{"name":"原生js实现jq","slug":"原生js实现jq","permalink":"https://wangpansheng.github.io/tags/原生js实现jq/"}]},{"title":"jquery框架封装练习01","date":"2016-11-15T07:07:04.000Z","path":"2016/11/15/原生框架封装练习01/","text":"我们通过原生的js实现一些jq的功能，通过练习，锻炼我们的分析问题的能力。锻炼编程的思维能力。 查询DOM方法 操作DOM方法 appendTo append prependTo prepend next/prev nextAll/prevAll before after parent /parents nextSibling attr prop val html text css addClass hasClass removeClass toggleClass on off click /dbclick/keydown $.ajax jQuery框架结构 为了防止对变量和全局对象的污染，使用沙箱模式 jq的功能是查询DOM和操作DOM， 在查询时，通过选择器来查询。因此要使用函数去实现Dom元素的查询。在实现时，要先定义一个函数init， 查询到DOM后，要对这些DOM进行操作，此时，要使用面向对象编程的方式来实现，创建一个对象，然后通过该对象的方法来实现操作查询到的DOM元素。 由于框架的结构在完成之后，不允许任何使用者随意改动，所以用户如果想要扩展方法，就必须向其能拿到的对象上扩展，$-&gt;createinit，也就是工厂函数以及其原型。最终要实现init对象继承自createinit函数的原型。 jQuery对象的本质是一个伪数组对象，在自然数的索引上存储的是查询到的DOM元素，本质是jQuery原型上的init构造函数的实例。 init构造函数的参数类型 构造函数中传入参数的类型有很多，所以我们需要对传入的参数进行判断，根据传入参数的不同，实现不同的功能。 string html字符串：创建对应的html元素 选择器：在DOM树上查询元素 dom元素 将其转换成init对象 dom数组和伪数组 转换成init对象 函数 其实就是入口函数 监听dom树是否加载完毕，如果加载完毕就执行函数 非法值 null undefined 返回空的init对象 添加类型判断方法 根据上面的类型需要做出判断，添加对应的怕段方法 isString方法：判断是否为字符串 isHTML方法：判断是否为html字符串 isDOM方法：判断是否是dom节点 isArrayLike方法：判断是否为数组或伪数组对象 isFunction方法：判断是否为函数类型 isWindow方法：判断是否为window对象","tags":[{"name":"js","slug":"js","permalink":"https://wangpansheng.github.io/tags/js/"},{"name":"原生js实现jq，原生框架封装","slug":"原生js实现jq，原生框架封装","permalink":"https://wangpansheng.github.io/tags/原生js实现jq，原生框架封装/"}]},{"title":"JS原型链总结","date":"2016-10-10T13:22:24.000Z","path":"2016/10/10/js原型/","text":"原型定义：是函数的prototype属性所引用的对象目的：为了同类对象之间的数据共享实际开发的使用1234567891011121314151617 // 1: 定义构造函数，实现函数体部分// 使用构造函数 结合原型function Person(name, age, sex) &#123; // 特有的属性写在这里&#125;// 2：将该对象相关的方法定义在原型上// 将共有的属性（一般是方法）Person.prototype.say = function() &#123;&#125;;Person.prototype.run = function() &#123;&#125;;// 或者Person.prototype = &#123; constructor: Person, say: function() &#123;&#125;, run: function() &#123;&#125;&#125;;// 3：创建对象var zs = new Person(); 继承定义：指一个对象有权去访问另一个对象上的成员继承的实现 原型式 混入式 借用构造函数 123456789101112function Animal( name, age, sex ) &#123; this.name = name; this.age = age; this.sex = sex;&#125;function Person( name, age, sex, phoneNo ) &#123; Animal.call( this, name, age, sex ); this.phoneNo = phoneNo;&#125;var zs = new Person( '张三', 18, 'boy', '13838383838' ); 原型链本质是通过__proto__属性连接起来的，体现继承层次关系的。掌握程度 给定一个对象，可以迅速找到该对象的原型链 找到该对象的三口之家 函数函数是js的一等公民 函数有双重身份 对象-可以添加属性和方法–静态成员 函数-在调用时，就存在四种调用模式；递归调用 可以嵌套使用 js使用词法作用域，那么会产生作用域链 可以作为其他函数的实参 回调函数 可以作为其他函数的返回值 闭包 可以限定作用域 可以作为对象的属性值` 哈哈哈哈","tags":[{"name":"JS","slug":"JS","permalink":"https://wangpansheng.github.io/tags/JS/"},{"name":"原型","slug":"原型","permalink":"https://wangpansheng.github.io/tags/原型/"},{"name":"原型链","slug":"原型链","permalink":"https://wangpansheng.github.io/tags/原型链/"},{"name":"函数","slug":"函数","permalink":"https://wangpansheng.github.io/tags/函数/"}]},{"title":"canvas入门2","date":"2016-09-11T00:54:50.000Z","path":"2016/09/11/canvas入门2/","text":"懒加载：现在不加载，用的时候再加载， 案例 移动的小球 实线思路： 简单版 利用计时器，定时执行 首先绘制一个圆形，圆从左上角出来，然后定时改变圆心的位置，再进行绘制， 等到x轴的坐标大于w或者小于0，改变每一步的正负值，使其反向运动， 鼠标进入再鼠标所在位置绘制圆形，然后开始下落 时钟案例 - 实现效果 ![cloc](/images/clock.png) - 实现思路 1. ​绘制表盘 待续","tags":[{"name":"JS","slug":"JS","permalink":"https://wangpansheng.github.io/tags/JS/"},{"name":"画布","slug":"画布","permalink":"https://wangpansheng.github.io/tags/画布/"},{"name":"Canvas","slug":"Canvas","permalink":"https://wangpansheng.github.io/tags/Canvas/"}]},{"title":"Canvas入门1","date":"2016-09-10T13:22:24.000Z","path":"2016/09/10/canvas入门1/","text":"概念：中文：“画布，帆布”HTML5提出一个新的标签。可以通过脚本语言（JS）在其上面绘制图形、图像以及制作动画。 基本使用 创建Canvas标签，同时指定canvas标签的大小；如果不指定的话，默认值为 300 * 150 （px） 如果想动态改变canvas的宽和高，必须通过其属性节点width以及height来改变，不能通过css样式来改变。 通过js获取到canvas对象。本身Canvas不具备绘图能力。 通过Canvas对象调用getContext方法来获取绘图的API方法 使用获取到绘图工具来绘制图形 getContext方法 语法: &lt;canvas对象&gt;.getContext(‘2d|WebGL’); 功能：获取绘制平面图形或立体图形的api方法以及相关属性；如果参数值为’2d’ ，表示获取绘制平面图形的工具；如果参数值为’WebGL’,表示获取绘制立体图形的工具。 基本绘图API ctx.moveTo(x, y) 移动笔触到指定点。 ctx.lineTo(x, y) 从笔触所在点连线到指定点 ctx.stroke(); 将当前路径绘制的图形描绘其边框 ctx.fill(); 填充一个封闭的图形（将当前路径形成一个封闭图形，然后在填充。） stroke方法与fill方法可以同时调用 开启新路径的方法 ctx.beginPath(); 闭合路径的方法 ctx.closePath();如果当前路径，没有形成一个封闭的图形，可以调用该方法来将图形闭合。 注意：beginPath与closePath不需要成对出现 非零环绕原则：是用来判断某一封闭的区域是否要填充。如果想判断指定区域是否填充，就在该区域内选择任意点，然后从该点引出一条射线，穿过整个图形到外部。查看该射线与图形的相交线，如果相交线是顺时针穿出射线，计数 + 1；如果是逆时针穿出射线，计数 -1；如果最后所有计数累加在一起，值不为0就填充该区域; 如果相交线是自上而下的穿出射线，即为顺时针穿出，计数 +1如果相交线是自下而上的穿出射线，即为逆时针穿出，计数 -1 奇偶原则：是用来判断某一封闭的区域是否要填充如果想判断指定区域是否填充，就在该区域内选择任意点，然后从该点引出一条射线，穿过整个图形到外部。查看该射线与图形的相交线的个数。如果为奇数，那么就填充；如果为偶数就不填充。 线性相关属性 设置线宽 ctx.lineWidth = value;","tags":[{"name":"JS","slug":"JS","permalink":"https://wangpansheng.github.io/tags/JS/"},{"name":"canvas","slug":"canvas","permalink":"https://wangpansheng.github.io/tags/canvas/"},{"name":"画布","slug":"画布","permalink":"https://wangpansheng.github.io/tags/画布/"}]},{"title":"关于js中的静态方法和实例方法","date":"2016-08-15T14:29:16.000Z","path":"2016/08/15/关于js中的静态方法和实例方法/","text":"最近有人问我关于什么静态方法和实例方法不是太清除，所以做一个整理。 什么是静态方法： 静态方法是指不需要声明类的实例就可以使用的方法。 代码演示123456function foo () &#123;&#125;;//在foo上直接添加静态方法foo.say = function()&#123; console.log(\"我是静态方法，不需要实例化，可以直接用函数调用!\");&#125;;foo.say();//函数直接调用方法say，打印hello 什么是实例方法 实例方法是指必须要先使用”new”关键字声明一个类的实例, 然后才可以通过此实例访问的方法。 代码演示：1234567function Fn () &#123; this.say = function()&#123; console.log(\"我是实例化之后才可以调用的方法！\") &#125;&#125;var obj = new Fn();//需要首先实例化obj.say();//才可以调用","tags":[{"name":"函数","slug":"函数","permalink":"https://wangpansheng.github.io/tags/函数/"},{"name":"js","slug":"js","permalink":"https://wangpansheng.github.io/tags/js/"},{"name":"静态方法","slug":"静态方法","permalink":"https://wangpansheng.github.io/tags/静态方法/"},{"name":"实例方法","slug":"实例方法","permalink":"https://wangpansheng.github.io/tags/实例方法/"}]},{"title":"AngularJS系列之模块化介绍","date":"2016-07-20T05:07:39.000Z","path":"2016/07/20/AngularJS系列之模块化介绍/","text":"模块化介绍 通过AngularJS构建应用时，是以模块化的方式组织的，即将整个应用划分成若干个模块，每个模块都各有其职责，最终组合成一个整体。 采用模块化的组织方式，可以最大程度的实现代码的复用，可以像搭积木一样进行开发。 定义应用 通过为任一HTML标签添加ng-app属性，可以指定一个应用，表示此标签所包裹的内容都属于应用的一部分。 123&lt;!--为html标签添加ng-app表明整个文档都是应用--&gt;&lt;!--ng-app属性可以不赋值，但是要关联相应模块时则必须赋值--&gt;&lt;html lang=&quot;zh-CN&quot; ng-app=&quot;App&quot;&gt;&lt;/html&gt; 定义模块 AngularJS提供了一个全局对象angular，在此全局对象下存在若干方法，其中angular.module()方法用来定义一个模块。 1234//通过module方法定义模块//需要传递两个参数，第一个表示模块的名字，// 第二个表示此模块依赖的其它模块var app = angular.module(\"app\",[]); 注：应用本质也是一个模块（一个比较大的模块）； 定义控制器 控制器（Controller）作为连接模型（model）和视图（view）的桥梁存在，所以当我们定义好了控制器以后，也就定义好了模型和视图。 1234567891011//app是一个模型实例对象//通过这个实例对象定义控制器，需要两个参数//第一个参数表示控制器名称，//第二个参数是一个数组，这个数组除最后一个单元是函数外，其余都是字符串，标明此控制器的依赖关系app.controller('studentController',['$scope',function($scope) &#123; //模型（model） $scope = [ &#123;name: \"李白\", sex: '男', age: \"23\"&#125;, &#123;name: '华仔', sex: '男', age: '34'&#125; ]&#125;]) 模型数据时要展示到视图上的，所以需要将控制器关联到视图上，通过为HTML标签添加ng-controller属性并赋值相应的控制器的名称，就确立了关联关系， 12345678910111213&lt;!--添加ng-controller属性，并赋值为相应的控制器名称--&gt; &lt;table ng-controller=\"StudentController\"&gt; &lt;tr&gt; &lt;th&gt;姓名&lt;/th&gt; &lt;th&gt;性别&lt;/th&gt; &lt;th&gt;年龄&lt;/th&gt; &lt;/tr&gt; &lt;tr ng-repeat=\"student in students\"&gt; &lt;td&gt;&#123;&#123;student.name&#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123;student.sex&#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123;student.age&#125;&#125;&lt;/td&gt; &lt;/tr&gt;&lt;/table&gt; 以上为AngularJS最基本的MVC工作模式。","tags":[]},{"title":"AngularJS系列之简单介绍","date":"2016-07-11T04:45:49.000Z","path":"2016/07/11/AngularJS介绍/","text":"AngularJS是Google公司开发维护的MVC前端框架；客服了HTMl在构建应用上的不足，降低了开发成本。 特点 jQuery更准确的说只是一个类库（类库指的是一系列函数的集合）以DOM作为驱动（核心），而AngularJS则是一个框架（诸多类库的集合）以数据和逻辑作为驱动（核心）。 框架对开发流程和模式做了约束，开发者遵照约束进行开发，更注重的实际的业务逻辑。 AngularJS有诸多特性，最为核心的就是：模块化，双向数据绑定，语义化标签，依赖注入等。 类似的框架的还有 BackBone，KnockoutJS，vue，Rect等， MVC MVC是一种开发模式，有模型（Model），视图（View），控制器（Controller），三部分组成，采用这种开发模式为合理组织代码提供了方便，降低了代码间的耦合度，功能结构清晰可见。 模型（Model）：一般用来处理数据（读取/设置），具体指操作数据库， 视图（View）：一般用来展示数据，比如通过HTML展示， 控制器（Controller）：一般用作连接模型和属兔的桥梁。 MVC被引入到前端开发中，由于受到技术的限制，便有了 一些细节的调整，于是出现了MVC的衍生版（子集）如：MVVM，MVW，MVP，MV*等；","tags":[{"name":"Angular","slug":"Angular","permalink":"https://wangpansheng.github.io/tags/Angular/"},{"name":"JS","slug":"JS","permalink":"https://wangpansheng.github.io/tags/JS/"}]},{"title":"git应用之git基本工作流程","date":"2016-06-13T05:58:24.000Z","path":"2016/06/13/git应用之git工作原理/","text":"初始化本地仓库 git init 如果我们想让git去管理某个目录下的文件，首先需要在该目录下初始化仓库。 三种状态 学习git之前，我们需要首先了解git管理的3种状态，分别是已提交，已修改，已暂存。 这三种状态分别对应三种目录空间， 已修改 -&gt; 工作目录 已暂存 -&gt; 本地仓库暂存区 通常存放在git目录中的HEAD或INDEX文件中 已提交 -&gt; 本地仓库的版本库 git基本工作流程 git的工作流程大概分成三个步骤： 在工作区域修改文件。 将工作目录的文件提交到暂存区域， 最后再将暂存区文件提交的本地版本库，形成一个版本保存起来 每一次从暂存区提交到版本库，都会形成一个新的版本库。","tags":[{"name":"git","slug":"git","permalink":"https://wangpansheng.github.io/tags/git/"},{"name":"版本控制","slug":"版本控制","permalink":"https://wangpansheng.github.io/tags/版本控制/"},{"name":"工具","slug":"工具","permalink":"https://wangpansheng.github.io/tags/工具/"}]},{"title":"git应用之版本控制工具","date":"2016-05-20T05:57:39.000Z","path":"2016/05/20/git应用之版本控制/","text":"版本控制工具版本控制工具可以解决的问题 代码合并 协同开发 提供效率 回退版本 数据丢失 分支管理-多任务处理 分类 集中式版本控制管理工具： 如：svn 在集中式版本控制工具中，都会有一个中央服务器，所有的协同开发者都需要来连接到这个服务器，将所有源代码都放在中央服务器上， 开发中，首先需要从中央服务器种下载代码（或者更新代码），然后在本地开发， 如果开发完毕，需要通过网络把开发完成的代码提交到中央服务器上。 这种方式解决了多人协同开发的问题，由于过渡依赖于网络和中央服务器， 如果中央服务器出现故障，将会严重导致数据版本丢失的风险， 另外，如果网路出现问题，也就没有办法更新，同步代码。 分布式 这种方式不需要中央服务器，每一个协同开发者，都是有一个完整的版本库，这样一来，任何协同开发者出现问题，事后都可以通过其它协同开发者进行恢复。 由于版本库在本地计算机，也就不再受网络影响，如果要将本地修改的代码推送给其它协同开发者，还需要一台 共享服务器，所有开发者通过这台服务器进行同步和更新。 分布式版本控制系统弥补了集中式版本控制工具的缺陷，成为了版本控制的首选，现在用的最多的就是Git。","tags":[{"name":"git","slug":"git","permalink":"https://wangpansheng.github.io/tags/git/"},{"name":"版本控制","slug":"版本控制","permalink":"https://wangpansheng.github.io/tags/版本控制/"},{"name":"工具","slug":"工具","permalink":"https://wangpansheng.github.io/tags/工具/"}]},{"title":"git应用之git和github","date":"2016-05-15T02:26:02.000Z","path":"2016/05/15/git应用之git和github/","text":"git和github的区别 git是一个软件，是一种版本控制工具，通过git命令提供的指令，方便管理源码，在实际开发时，可以将更多的经理集中在开发上，而不是要分出精力去管理代码的合并和版本控制问题。 github是一个网站，提供远程仓库，方便开发人员的交流学习。 github可以为git提供一些服务，比如 远程共享仓库，以及开发人员的交流平台。 配置SSH免密码下载 ssh-keygen -t rsa git指令 从远程服务器上获取指定仓库的分支，并且与工作目录的分支进行合并操作，如果出现问题，需要手动解决就好。 1git pull [remote url] branchName 如果本地开发完成，要将本地仓库的版本提交到远程仓库，实现共享与项目合并，此时就是用这个指令。 1git push [remote url] branchName 获取远程仓库，但是不合并本地仓库 1git fetch [remote url] branchName 把远程仓库的地址存在变量name中，方便以后拉取远程仓库文件 1git remote add name remoteURL 如果是拉取远程仓库中的子分支上的文件时，需要在本地首先创建一个同名的子分支 ，否则会把远程仓库子分支中的文件拉取到本地主分支上","tags":[]},{"title":"git应用之vi编辑器","date":"2016-05-14T04:02:20.000Z","path":"2016/05/14/git应用之vi编辑器/","text":"认识vi vi编辑器是Linux下的标配，通过它我们可以创建，编辑文件，它是一个系统自带的文本编辑器， 在bash命令行输入 vi 文件名，即可打开文件，进入vi编辑模式。 三种模式 vi编辑器提供了3种模式，分别是命令模式,插入模式，末行模式，每种模式下用户所能进行的操作是不一样的。 3种模式的切换如下图： 通过上图我们发现，输入模式是不能直接切换到末行模式的，必须要先切换到命令模式。 VI编辑器快捷键末行模式： :w(小写) 保存； :w filename 另存为； :q 退出 :wq 保存并退出 :e! 撤销更改 :q! 不保存强制退出 :set nu 设置行号 命令模式 ZZ(大写) 保存并退出 u 撤销操作，可多次使用 dd 删除当前行 yy 复制当前行 p 粘贴内容 ctrl+f 向前翻页 ctrl+b 向后翻页 i 进入编辑模式，在当前光标插入 a 进入编辑模式，在当前光标后插入 A 进入编辑模式，光标移动到行尾 o 进入编辑模式，当前行下面插入新一行 O 进入编辑模式，当前行上面插入一行 编辑模式 编辑模式下，操作和正常widows编辑器操作类似","tags":[{"name":"git","slug":"git","permalink":"https://wangpansheng.github.io/tags/git/"},{"name":"vi","slug":"vi","permalink":"https://wangpansheng.github.io/tags/vi/"},{"name":"vim","slug":"vim","permalink":"https://wangpansheng.github.io/tags/vim/"}]},{"title":"AJAX应用之基本功","date":"2016-05-13T13:10:23.000Z","path":"2016/05/13/AJAX学习之基本功/","text":"静态资源和动态资源 我们把开发好的html css js部署到服务器上，然后就可以访问了，我们称这些服务器上的文件为资源。 我们把资源分为两类： 实际上，我们开发都是在开发资源，开发好了部署到服务器上，然后客户端就可访问我的资源了。 资源分为两类 静态资源 可以通过浏览器直接打开，直接解析的我们称为静态资源。html,js,css.inage 我们可以理解为静态资源 动态资源 php，jsp，asp 我们可以理解为动态资源 动态资源和静态资源的区别 浏览器只认识静态资源。 我的浏览器通过输入地址区访问呢服务器，实际上是去访问服务器上的资源。 服务器上有静态资源，也有动态资源。 如果我的浏览器访问的是服务器上的动态资源，服务器会把动态资源转换称静态资源，然后在传给客户端浏览器。 如果我的浏览器访问的是服务器上的静态资源，那么服务器会直接把静态资源传送给浏览器解析。 动态资源是在服务端运行的，静态资源是在客户端运行的。 php 就是在服务端运行的，用来处理服务端逻辑的。 客户端与服务端进行交互客户端发送请求有几种方式： 在地址栏输入地址发送请求 点击一个超链接，发送请求 表单提交也是属于发送请求 发送请求是给服务器端进行提交，提交数据到服务器 提交有两种常见的方式，一个是get，一个是post 1. 什么是get提交 在地址栏输入地址发送请求，点击超链接也属于get提交 表单提交，&lt;form action=&quot;&quot; method=&quot;get&quot;&gt;&lt;/form&gt;默认是get方式提交。 ?paraName=value&amp;paraName=value&amp;paraName=value 2. 什么是post提交呢？ 表单提交，可以设置称post方式提交， 会自动把数据发送到服务器 3. 服务端 接收请求$_GET $POST这两个变量得到的值是一个关联数组，客户端的数据放在关联数组里面，需要根据key去获取里边的值 处理请求连接数据库，增删改查 响应数据echo根据处理请求的逻辑，给客户端不同的响应结果 服务端接收到客户端的请求，一般要做那些处理？1.用户登录 接收请求，接收用户名以及密码 对接收到的用户名密码进行判断， 如果正确，则进行连接数据 如果不正确就提示错误 2.文件上传 客户端： 必须是表单提交的 表单提交里面必须有一个 input type=“file” 必须是post方式提交的 必须给表单设置一个属性，enctype=&quot;multipart/form-data 服务端（php） 要接收客户端的数据， $_GET, $_POST ,不能接收文件上传的数据，文件上传的数据，我们应该用$_FILES 的变量去接收，接收的数据也是一个关联数组 接收到这个数据之后，需要把这些数据保存到服务端硬盘上面。","tags":[{"name":"ajax","slug":"ajax","permalink":"https://wangpansheng.github.io/tags/ajax/"},{"name":"基本功","slug":"基本功","permalink":"https://wangpansheng.github.io/tags/基本功/"}]},{"title":"git应用之git常用操作","date":"2016-05-13T05:59:09.000Z","path":"2016/05/13/git应用之git常用操作/","text":"这篇主要介绍的是如何配置git和相关操作命令，方便交流学习和以后查阅。 1. 配置用户 git安装完成之后，我们需要配置个人信息，配置方式如下。 git config [option] –global 全局配置，当前用户下的所有仓库都共享同一个用户的配置信息 –system 系统配置，该电脑下的所有仓库都共享一个用户的配置信息 –local 本地配置，该仓库下使用当前配置的用户信息。 配置用户名：git config –global user.name “wangpansheng” 配置邮箱： git config –global user.email “wps@qq.com“ 获取信息： git config –get user.name || –get user.email 配置信息存放在用户文件夹中的.gitconfig中存放着。 可以通过重复配置信息，覆盖之前配置的信息 2. 仓库初始化 使用git管理代码之前需要首先在工作目录下，输入该命令，初始化一个仓库。 git init 3. 查看文件状态 查看当前工作目录文件的状态， 如果下边文件名是红色的就是没有被追踪的，或者是暂存之后又被修改的文件。 如果绿色的就是已经add暂存了的文件。 会忽略空文件夹 medified 表示是跟踪到修改的文件 git status 4. 添加到暂存区 如果要把本地工作目录的文件添加到暂存区，也就是想要让git追踪文件的变化，就需要使用git add命令。然后使用git status查看文件状态是否被追踪。 git add [option] *| -A 暂存所有文件 文件名，暂存指定文件 5. 撤销更改 有时候，我们可能会想要把代码恢复到以前的版本，这是就需要用到checkout了。 在撤销更该的时候，如果暂存区有备份，就恢复暂存区文件到工作目录， 如果暂存区没有就去版本库去恢复。 git checkout filename 6. 提交 git commit [option] -m “当前版本备注信息” 提交单个文件时，option输入文件名即可， 在做版本回退时，需要根据版本备注信息选择回退的版本。 没提交一次都会有一个版本号，一般称为SHA值， 7. 查看提交日志 有时候我们需要查看提交的历史纪录，可以通过git log查看提交的历史记录 git log 不包含回退之后的版本 git log –oneline 简略显示日志 git reflog 查看所有历史版本， 8. 恢复之前提交的状态 回退到指定的版本 git reset [option] 版本id 将指定版本内的文件替换掉工作目录内的文件，实现版本回退， 如果传了 –hard 会同时更改暂存区文件 git reset HEAD^ 回退到前一次提交的版本， git reset HEAD^^|| HEAD~2回退到前两次的版本 reset命令有3中方式： git reset –mixed 默认方式，不带任何参数的git reset， 版本区和暂存区变化，工作区不变化 git reset –soft 回退到某个版本，只回退了commit的信息，不会恢复暂存区， 如果还要提交，直接commit即可 git reset –hard 彻底回退到某个版本，本地的源码也会变为上一个版本的内容。 9. git分支 在初始化一个本地仓库时，默认是没有主分支的，必须至少提交一次版本之后，git才会创建master主分支。 git在创建分支时，必须保证有master主分支。 创建分支 git branch name 创建分支 git checkout -b branchName 创建分支并切换到该分支 查看分支 git branch 有星号*标记的分支，就是当前工作目录所在的分支， 切换分支 git checkout branchName 切换到指定分支 分支的合并 git merge branchName 将指定分支合并到当前分支 删除分支 git branch -d branchName 删除指定的分支 git分支策略 在实际开发中，虽然git分支很强大，但是也不是随便用的，通常我们需要按照一定的策略使用分支，提高开发效率。 保证主分支的的稳定性，也就是说要保证主分支的代码，无bug，功能完整，不能在主分支上直接进行开发。 如果需要开发新功能时，那么就创建一个该功能的分支，然后在该分支上进行代码编写。当功能开发完毕，并且测试无bug，将该分支上的代码合并到主分支上。 该分支命名一般规范：所有的开发分支都以”dev-“+相关功能描述的单词。 eg： 要开发登录功能时， 此时可以考虑创建一个开发分支，名字为dev-login 如果开发时遇到协同开发，就要创建协同开发分支，在该分支上去编写代码。 当代码合并时，可能会出现，代码冲突，一旦出现冲突，git无法解决，需要我们认为手动去处理。 该分支一般的命名规范为： 所有的开发分支都以”feature-“+相关描述词； eg：开发主页功能时，可以考虑创建一个分支，名字为feature-index 如果在开发时，接到一个临时修改的bug的任务时，此时不要在主分支或当前未完成的分支上去修改，此时，创建一个bug分支，在该分支上去修改出现bug的代码，修改完成之后，将其合并到主分支， 该分支命名规范： 所有的开发分支都以”bug”+相关描述词； eg: 要修改登录超时问题，此时可以考虑创建一个bug分支，名字为bug-loginTimeout 如果出现冲突，必须手动解决冲突，然后重新提交版本，","tags":[{"name":"git","slug":"git","permalink":"https://wangpansheng.github.io/tags/git/"},{"name":"常用命令操作","slug":"常用命令操作","permalink":"https://wangpansheng.github.io/tags/常用命令操作/"}]},{"title":"git应用之认识bash","date":"2016-05-13T01:22:24.000Z","path":"2016/05/13/git快速入门之bash/","text":"什么是shellShell俗称壳，是指”提供使用者使用界面”的软件，接收用户命令，然后调用相应的应用程序。 shell分类图形化shell通过友好的可视化界面，调用相应应用程序，如windows系类操作系统，类Unix，Linux系统上的图形化应用程序Gnome，Kde等。 命令行shell通过输入特定命令调用相应的应用程序。如window系统的cmd，Windows PowerShell；Linux系统的bash。 认识bash 在window下使用bash，需要一个软件，这个软件模拟集成了bash大部分命令， 各个shell的功能都差不多，linux默认使用bash，所以主要学习bash。 bash常用命令 pwd(Print Working Directory) 查看当前目录; cd(Change Directory) 切换目录，如cd etc,cd ..返回上一层目录; ls(List) 查看当前目录下内容，如ls-al; ls -l 以列表形式产看当前目录内容 mkdir(Make Directory) 创建目录，可以指定路径创建目录，如mkdir blog; touch 创建文件， cat 查看文件全部内容，cat ./路径/文件名 more(unix支持) less(linux支持) 分页查看文件，空格翻页，q退出。 rm(remove) 删除文件，如rm 文件名 rm -rf 强制删除目录内所有文件，-r(recursion)是递归删除，-f强制删除 rmdir(Remove Directory) 删除文件夹，只能删除空文件夹 mv(move) 移动文件或重命名,mv index.html ./00/00/index.html cp(copy) 复制文件 head 查看文件前几行，如 head -g index.html tail 查看文件后几行， -n-f, tab 自动补全，连续按两次会将所有匹配内容显示出来 history 查看操作历史 ssh 远程免密码登录，如ssh root@gitlab.study.com 和 &gt;&gt; 重定向，&gt;覆盖，&gt;&gt;追加，如cat index.html &gt; log.txt; clear 清空当前窗口 curl 网络请求， whoami 查看当前用户 以下在winodw集成环境不支持 weget 下载 tar 解压缩 管道符可以将多个命令来连接在一起，上一次命令的执行结果当成下一次命令的参数。 grep 匹配内容，一般结合管道符使用。","tags":[{"name":"git","slug":"git","permalink":"https://wangpansheng.github.io/tags/git/"},{"name":"shell","slug":"shell","permalink":"https://wangpansheng.github.io/tags/shell/"},{"name":"bash","slug":"bash","permalink":"https://wangpansheng.github.io/tags/bash/"}]},{"title":"git应用之认识SSH","date":"2016-05-10T04:02:43.000Z","path":"2016/05/10/git应用之认识SSH/","text":"什么是SSH SSH是一种网络协议，用于计算机之间的加密登录。 SSH只是一种协议，存在多种实现，既有商业实现，也有开源实现。我们主要针对OpenSSH，它是自由软件，应用非常广泛。 如果要 在widows种使用SSH，会使用到一种软件PuTTY，我们用的git客户端也集成了SSH。 格式：ssh user@host user 代表用户，host代表要登录的远程计算机 常见的两种加密方式 常见的两种加密技术，分别是对称性加密和非对称性加密，SSH属于后者。 对称性加密算法，在加密和解密时，使用的是同一个密钥； 而非对称性加密算法需要两个密钥来进行加密和解密。这两个密钥分别是公开密钥(public key,公钥)和私有密钥(private key,私钥)。 非对称性加密的工作原理 公钥和私钥是成对出现，可以通过ssh-keygen -t rsa来创建，既可以通过密钥加密数据，也可以过通过私钥来加密数据，如果是以公钥进行的数据加密，只有通过与之对应的私钥才可解密，相反，如果以私钥进行的数据加密，则只能通过与之对应的公钥才可将数据解密，这样就可以提高信息传递的安全性， 免密码登录 我们可以将本地机器上的公钥保存到特定的远程计算机上，这样当我们再次登录访问这台远程计算机时就可以实现免密码登录了。 ssh-keygen -t rsa 会创建公钥和密钥（默认在用户目录/.ssh中） ssh-copy-id user@host 添加到对应远程主机的用户目录/.ssh目录下 也可以登录远程主机，进入到用户目录/.ssh目录下手动创建authorized keys文件，并将自己的公钥粘贴到该文件。","tags":[{"name":"git","slug":"git","permalink":"https://wangpansheng.github.io/tags/git/"},{"name":"工具","slug":"工具","permalink":"https://wangpansheng.github.io/tags/工具/"},{"name":"SSH","slug":"SSH","permalink":"https://wangpansheng.github.io/tags/SSH/"}]},{"title":"什么是ajax","date":"2016-04-24T09:16:19.000Z","path":"2016/04/24/ajax是什么/","text":"什么是ajax 1. 同步交互 客户端请求服务器，服务器接收到请求，处理请求，然后给客户端一个响应，响应的数据会把原来的页面给覆盖。我们把这种交互成为同步交互. 2. 异步交互客户端请求服务器,服务器接收到请求，处理请求，然后给客户端一个响应， 响应的数据不会把原来的页面给覆盖。我们把这种交互成为异步交互. 异步交互实际上就是页面不刷新，就可以动态的去获取服务端的数据 它是怎么做到的，为什么能够去获取到服务端的数据，它的原理是什么.通过XMLHttpRequest 对象去发送http 请求. XMLHttpRequest 交互的几个步骤 创建这样的一个对象 我要跟服务端建立一个连接 我要在连接上面发送数据 接收服务端返回的数据 页面不刷新，就完成了跟服务器端的数据交互. 我假设以后我们做登录是同步交互，还是做异步交互. 昵称： 密码： 如果我是做同步登录 肯定是服务器得到我的请求，决定给我输出什么样的数据。 如果是做异步登录 给登录按钮添加点击事件，然后获取到用户名，以及密码然后通过XMLHttpRequest 对象发送请求给服务器，服务器返回数据返回了数据之后，然后接收到数据，我肯定是登陆成功，还是失败，然后由客户端来完成跳转window.location.href=””; ajax运行过程我们做ajax 开发，客户端发送一个请求给服务器，服务器返回数据。返回了数据之后，我通过js 得到数据，得到了数据之后，我把这个数据渲染到页面上面. xml和json如果跟服务器进行交互，如果传递的数据格式非常大，非常多的情况下，我们一般给传递是数据规定一个格式. 这个格式有两种，目前市场上面，一种是xml 的数据格式，还有一种是json 的数据格式.xml 跟这个json 都是数据格式。 xml xml 到底是什么样的数据格式 xml 是 可扩展的标记语言，html是超文本标记语言，都是由标记，标签组成， xml 它里面的标签是自定义的， 主要是用来做软件的配置文件，用来做数据的传输，xml 一般自己写解析 xml 里面的标记的语法： 第一：第一行必须是文档申明 &lt;?xml version=”1.0” encoding=”utf-8” ?&gt; 第二：必须有且仅有一个根元素 第三：标签可以嵌套，不能交叉嵌套 &lt;persons&gt;&lt;person&gt;&lt;/person&gt;&lt;/persons&gt; html 里面的标记 是w3c 指定的需要按照w3c 指定的规范去编写 主要是用来做界面显示的，浏览器解析. 一般每一门语言对xml，以及json 都有解决方案","tags":[{"name":"ajax","slug":"ajax","permalink":"https://wangpansheng.github.io/tags/ajax/"}]},{"title":"hexo搭建博客常见问题","date":"2016-04-24T08:47:17.000Z","path":"2016/04/24/hexo搭建博客常见问题/","text":"1. 当执行hexo-d时报错,执行以下代码之后,重新提交就可以了1git config --global core.autocrlf false 2. ENOSPC报错 在ubuntu系统中，执行hexo时，出现ENOSPC报错,可以运行来修复$ npm dedupe，如果还是不行，尝试以下命令：（亲测可行）1$ echo fs.inotify.max_user_watches = 524288 | sudo tee -a /etc/sysctl.conf &amp;&amp; sudo sysctl -p","tags":[{"name":"hexo ubuntu","slug":"hexo-ubuntu","permalink":"https://wangpansheng.github.io/tags/hexo-ubuntu/"}]},{"title":"ECMAScript发展史","date":"2016-03-18T01:59:57.000Z","path":"2016/03/18/ECMAScript发展史/","text":"ECMAScript是一种由Ecma国际（前身为欧洲计算机制造商协会）通过ECMA-262标准化的脚本程序设计语言。这种语言在万维网上应用广泛，它往往被称为JavaScript或JScript，但实际上后两者是ECMA-262标准的实现和扩展。目录 历史 版本 方言 对应版本 参考文献 参见 外部链接1. 历史 1995年12月，升阳公司与网景公司公司一起引入了JavaScript[1]。1996年3月，网景公司发表了支持JavaScript的网景导航者 2.0。由于JavaScript作为网页的客户端脚本语言非常成功，微软于1996年8月引入了Internet Explorer 3.0，这个软件支持一个“约”与JavaScript相容的JScript[2]。1996年11月，网景公司将JavaScript提交给欧洲计算机制造商协会进行标准化。ECMA-262的第一个版本于1997年6月被Ecma组织采纳。ECMAScript是由ECMA-262标准化的脚本语言的名称。JavaScript和JScript与ECMAScript相容，但包含超出ECMAScript的功能。 3. 版本 至今为止有七个ECMA-262版本发表。 1 | 1997年6月 | 首版 | 2 | 1998年6月 | 格式修正，以使得其形式与ISO/IEC16262国际标准一致| 3 | 1999年12月 | 强大的正则表达式，更好的词法作用域链处理，新的控制指令，异常处理，错误定义更加明确，数据输出的格式化及其它改变| 4 | 放弃 | 由于关于语言的复杂性出现分歧,第4版本被放弃,其中的部分成为了第5版本及Harmony的基础。| 5 | 2009年12月[4] | 新增“严格模式（strict mode）”，一个子集用作提供更彻底的错误检查,以避免结构出错。澄清了许多第3版本的模糊规范,and accommodates behaviour of real-world implementations that differed consistently from that specification。增加了部分新功能,如getters及setters,支持JSON以及在物件属性上更完整的反射。| 6 | 2015年6月 | 多个新的概念和语言特性。ECMAScript Harmony将会以“ECMAScript 6”发布。| 7 | 2016年6月[9] | 多个新的概念和语言特性| | | 2004年6月Ecma组织发表了ECMA-357标准，它是ECMAScript的一个扩延，也被称为E4X（ECMAScript for XML）。|","tags":[{"name":"ECMA","slug":"ECMA","permalink":"https://wangpansheng.github.io/tags/ECMA/"}]},{"title":"AJAX应用之HTTP","date":"2016-03-14T11:42:23.000Z","path":"2016/03/14/AJAX应用之HTTP/","text":"http 协议。 协议就是约束，http协议是w3c制定的，用来约束客户端浏览器与web服务器进行通讯的数据格式,http 协议是基于请求，响应的协议。客户端浏览器给服务器发送一个请求，服务器给客户端一个响应 http协议的数据格式分为两部分 客户端发送到服务器的请求，称为请求的数据格式。 服务器响应给客户端的数据，为响应的数据格式. 请求的数据格式，是客户端发送给服务器的，分为四个部分 请求首行 请求头 请求空行 请求体 1. get请求数据格式 请求首行 123456GET /day08/code/01http/01get.html HTTP/1.1[GET 告诉服务器提交方式][/day08/code/01http/01get.html 告诉服务器，我要去请求的资源的地址][HTTP/1.1 协议的版本] 有两个版本，1.01.1 请求头 12345678910Host 127.0.0.1 【请求头的名称，请求头的值】Cache-Control max-age=0 这个做缓存控制的.Upgrade-Insecure-Requests 1 没有用过.User-Agent Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/53.0.2785.143 Safari/537.36 这个是告诉服务器，我客户端浏览器的版本，操作系统的版本Accept text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8 接收，告诉服务器，我客户端可以接收那些数据格式.Referer http://127.0.0.1/day08/code/01http/Accept-Encoding gzip, deflate, sdch 接收的压缩格式. gzipAccept-Language zh-CN,zh;q=0.8 接收的语言If-None-Match &quot;7700000000217a-96-548afe60e947a&quot;If-Modified-Since Fri, 17 Feb 2017 01:33:19 GMT 2. post 请求的数据格式的介绍 请求首行1POST /day08/code/01http/02post.php HTTP/1.1 请求头 12345678910111213141516171819202122Host: 127.0.0.1内容长度，指的 请求体的长度Content-Length: 21缓存的Cache-Control: max-age=0请求的站点的主域名Origin: http://127.0.0.1Upgrade-Insecure-Requests: 1告诉服务器客户端浏览器的版本，操作系统的版本.User-Agent: Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/53.0.2785.143 Safari/537.36//这个是post 提交独有第一个请求头，如果发送到服务器的数据有中文，会吧中文进行编码在发送给服务器，服务器得到数据会自动解码.Content-Type: application/x-www-form-urlencoded//接收的数据格式Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8告诉服务器，请求来自于那个页面Referer: http://127.0.0.1/day08/code/01http/02post.html接收压缩格式Accept-Encoding: gzip, deflate接收的语言Accept-Language: zh-CN,zh;q=0.8请求空行 [用来将请求头跟请求体进行一个区分，方便服务器解析数据] 请求体[客户端发送到服务器的数据.] 1username=dasfadsfdafs 3. get 跟post 的区别： get 提交请求的数据都在地址栏中，相对来不安全。 get 请求的数据都请求地址的后面，对请求的数据的大小由限制，限制大概1kb get 没有请求体 ost 请求的数据在请求体当中，相对来说安全 ost 请求的数据大小没有限制。文件上传，这个必须是post 方式提交 ost 提交有一个特殊的请求头:Content-Type:application/x-www-form-urlencoded可以对请求的数据包含中文的数据进行编码. get 的请求没有没有请求体，也会少一些请求头，所以它传递到服务端的数据要少一些。性能要高一些。 4. 服务器响应给客户端的数据也分为四个部分 响应首行 响应头 响应空行 响应体 1. 响应首行123协议的版本200 状态吗 代表okHTTP/1.1 200 OK 实际上我们开发的过程当中还有很多的状态吗404 代表请求的资源没有找到，以后假设出现404500 代表服务器内部错误405 代表请求的方式不支持,如果我的一个php接收post 方式的数据 $_POST然后你以get 方式去请求，就会出现405304 请求的资源没有发生改变. 这个是用来做缓存用的.当我第一次访问http://127.0.0.1/day08/code/01http/01get.html这个页面，服务器会给我一个响应头.Last-Modified:Fri, 17 Feb 2017 01:33:19 GMT告诉客户端浏览器，这个文件的最后修改时间. 当我再次去访问http://127.0.0.1/day08/code/01http/01get.html会给服务器协议这样的一个请求头If-Modified-Since:Fri, 17 Feb 2017 01:33:19 GMT这个时候服务器就会给客户端一个304 的状态吗，你请求的这个资源http://127.0.0.1/day08/code/01http/01get.html 没有做任何的修改客户端浏览器得到是304，它就会从本地去读取页面 2. 响应头告诉客户端服务器端的时间.Date: Fri, 17 Feb 2017 01:35:58 GMT告诉客户端服务器的版本Server: Apache/2.2.21 (Win32) PHP/5.3.10文件的最后修改时间Last-Modified: Fri, 17 Feb 2017 01:33:19 GMT ETag: “7700000000217a-96-548afe60e947a”Accept-Ranges: bytes内容的长度Content-Length: 150//内容类型，告诉客户端浏览器，我给你返回的是一个文本，html 格式的文本,客户端浏览器得到这个，就会以html 的方式去解析.Content-Type: text/html;header(“Content-Type:text/html;charset=utf-8”) 3. 响应空行4. 响应体客户端发送到服务器的时候有一个请求头叫做User-Agent:告诉服务器客户端浏览器的版本，操作系统的版本. 5. 响应的头，Refresh 的响应头服务器给客户端，如果客户端得到这个响应头，它会自动跳转页面. Referer 的头，告诉服务器，请求来自于那个页面. 1:广告流量统计，统计到我的网站在那个网站上面打的广告更加有效果。 2：防盗链，bs 架构，我们可以看到后台的链接，一个连接对应一个资源。 互联网上创业，有些软件做功能，有些软件做内容。 一个连接对应一个资源 ，视频行业，最砸钱，谁有视频的资源。视频的资源 现在都要买版权，都要收费。 www.kuaibo.com ，进入到快播的一个页面， 快播视频播放，我就可以引入优酷上面的一个视频资源。 这个时候会给优酷发送一个请求，就会优酷携带一个请求头 Referer:www.kuaibo.com 我在优酷的后台我就可以判断，如果你请求的Referer 的值不是来自于优酷自己的站点我让你跳转优酷的首页，看看广告. http 协议 里面面试的时候一些重点的东西： 1:get 跟post 的区别 2:请求的数据格式， 特殊的请求头 post 提交有一个特殊的请求头 Content-Type:&quot;application/-w-form-data&quot; 3:响应的数据格式。 你知道哪些常见的状态吗 200 404 405 500 304 请求的资源没有发生任何改变，浏览器从缓存里面去找 302 请求重定向 http://www.tieba.com 这个地址会给我一个302 的状态吗 它还会给以location 的地址 302 Location:http://tieba.baidu.com //响应头：地址 你在请求开发的过程当成碰到什么乱码问题没有 1：客户端的数据发送到服务器， 1:如果说有中文，我们一般使用post 方式提交 //使用js 对魔兽.exe 进行编码. utf-8 //服务器根据这个去进行解码. 以utf-8 去解码 2:&lt;a href=&quot;adsfadsf.php?fileName=&quot;魔兽.exe&quot;&gt;问价下载 &lt;/a&gt; 2：服务器的数据响应给客户端。 1： 当前文件采用的是什么编码 2: 然后 给客户端一个响应头 Content-Type:text/html;charset=当前文件的编码","tags":[{"name":"ajax","slug":"ajax","permalink":"https://wangpansheng.github.io/tags/ajax/"},{"name":"http","slug":"http","permalink":"https://wangpansheng.github.io/tags/http/"}]},{"title":"快速搭建hexo个人博客站点","date":"2016-03-10T15:51:18.000Z","path":"2016/03/10/hexo配置个人博客站点/","text":"1. 首先安装hexo命令行，123sudo npm install hexo-cli -g//安装之后输入下面命令验证是否安装成功hexo -v 2. 接着我们找一个我们打算把博客放在打文件夹中，打开终端12345//输入下面命令，会自动部署博客框架hexo init [blog]//blog 就是我们防止博客文件的文件夹，可以不写，就会在打开终端打目录下直接创建//完成之后，进入blog文件夹安装依赖npm install 3. 本地预览1hexo s 输入命令之后，看到下面这行提示之后，就可以再浏览器输入地址，预览配置好的页面。12INFO Start processingINFO Hexo is running at http://localhost:4000/. Press Ctrl+C to stop. 4. 创建新文章1hexo new 文章标题 输入命令之后，就可以再\\hexo\\source_posts\\路径下看到自己输入名字的md文件，文章标题默认就是创建时候写的。 5. 生成部署1hexo g 输入命令之后，会生成静态页面， 6. 提交1hexo d 输入命令，可以把生成的静态页，提交到自己的github主页上。","tags":[{"name":"hexo","slug":"hexo","permalink":"https://wangpansheng.github.io/tags/hexo/"},{"name":"个人博客","slug":"个人博客","permalink":"https://wangpansheng.github.io/tags/个人博客/"},{"name":"技术分享","slug":"技术分享","permalink":"https://wangpansheng.github.io/tags/技术分享/"}]},{"title":"markdown基本语法","date":"2016-01-14T00:56:31.000Z","path":"2016/01/14/markdown基本语法/","text":"标题 标题是每篇文章都需要也是最常用的格式，在 Markdown 中，如果一段文字被定义为标题，只要在这段文字前加 # 号即可。 123456# 一级标题## 二级标题### 三级标题 以此类推，总共六级标题，建议在井号后加一个空格，这是最标准的 Markdown 语法。 在Markdown当中设置标题，还有第二种方式：通过在文字下方添加“=”和“-”，他们分别表示一级标题和二级标题。 列表熟悉 HTML 的同学肯定知道有序列表与无序列表的区别，在 Markdown 下，列表的显示只需要在文字前加上 - 或 * 即可变为无序列表，有序列表则直接在文字前加1. 2. 3. 符号要和文字之间加上一个字符的空格。 引用 如果你需要引用一小段别处的句子，那么就要用引用的格式。 只需要在文本前加入 &gt; 这种尖括号（大于号）即可 图片与链接 插入链接与插入图片的语法很像，区别在一个 !号 123图片为：![]()&#123;ImgCap&#125;&#123;/ImgCap&#125;链接为：[]() 粗体与斜体 Markdown 的粗体和斜体也非常简单，用两个 包含一段文本就是粗体的语法，用一个 包含一段文本就是斜体的语法。 表格 表格是我觉得 Markdown 比较累人的地方，例子如下： 12345| Tables | Are | Cool || ------------- |:-------------:| -----:|| col 3 is | right-aligned | $1600 || col 2 is | centered | $12 || zebra stripes | are neat | $1 | 这种语法生成的表格如下：| Tables | Are | Cool || ————- |:————-:| —–:|| col 3 is | right-aligned | $1600 || col 2 is | centered | $12 || zebra stripes | are neat | $1 | 代码框如果你是个程序猿，需要在文章里优雅的引用代码框，在 Markdown下实现也非常简单，只需要用两个 ` 把中间的代码包裹起来。图例： 使用 tab 键即可缩进。 分割线分割线的语法只需要三个 * 号，例如： 到这里，Markdown 的基本语法在日常的使用中基本就没什么大问题了，只要多加练习，配合好用的工具，写起东西来肯定会行云流水。更多的语法规则，其实 Mou 的 Help 文档栗子很好，当你第一次使用 Mou 时，就会显示该文档。可以用来对用的查找和学习。 相关推荐:工具 图床工具用来上传图片获取 URL 地址 DroplrCloudappezShare for Mac围脖图床修复计划在线好用的Markdown工具，为印象笔记而生 马克飞象，专为印象笔记打造的Markdown编辑器，非常推荐相关文章阅读： 为什么作家应该用 Markdown 保存自己的文稿","tags":[{"name":"markdown","slug":"markdown","permalink":"https://wangpansheng.github.io/tags/markdown/"},{"name":"语法","slug":"语法","permalink":"https://wangpansheng.github.io/tags/语法/"}]},{"title":"把markdown文件转换为html文件","date":"2016-01-13T05:57:39.000Z","path":"2016/01/13/markdown2html/","text":"MarkDown自动转换html页面 因为markdown语法的方便，平常我经常用markdown来做一些笔记，但有时候需要把md文件转换成html页面，所以现在就把转换方法简单记录下，方便大家学习。不过肯定有别的更好的方法，如果你看到了，觉得你有更好的方法，希望你能不吝赐教，交流学习！ 插件安装 首先第一步肯定是安装转换工具了，我现在用的是i5ting_toc这个工具，这个工具是依赖node的，所以需要先安装node的，node的详细安装方法，这里就不细说了，如果不会的，可以去问问老李（百度）， 然后在npm中执行以下命令，npm会自动安装， 1npm install -g i5ting_toc 文件转换 安装完成之后，就开始准备转换了，那么我们在你要转换的markdown文件的文件夹，按住shift键右键点击文件夹空白地方，会弹出右键菜单，然后选择“打开命令行窗口”选项，接着在命令行输入以下命令，系统就会自动输出html文件。 123i5ting_toc -f note.md -o//note.md 为需要转换的文件名//-o 在转换完成之后会自动打开html页面 完毕，至此，我们的文件已经转换完成了，至于更换模板什么的，我现在还不知道怎么弄，望知道的大神指点一二。不胜感激！","tags":[{"name":"markdown","slug":"markdown","permalink":"https://wangpansheng.github.io/tags/markdown/"},{"name":"转换，html","slug":"转换，html","permalink":"https://wangpansheng.github.io/tags/转换，html/"},{"name":"i5ting_toc","slug":"i5ting-toc","permalink":"https://wangpansheng.github.io/tags/i5ting-toc/"}]},{"title":"PHP简单入门","date":"2015-08-14T11:52:11.000Z","path":"2015/08/14/PHP简单入门/","text":"php基础 定义变量 变量使用$开头，不能以数字开头， 大小写敏感(区分大小写) php代码必须写在&lt;?php 代码 ?&gt;, 在第一行加上下面这行代码可以防止中文乱码问题 1header(\"Content-Type:text/html;charset=utf-8\"); php变量的类型： 字符串，整型，浮点型，布尔类型，数组 函数 与js基本一致 函数的形参可以设置一个默认值。1234function foo($username = &quot;zs&quot;) &#123; echo &quot;你好&quot;.$username;&#125;foo(); 数组 php里面有两种类型的数组，普通数组和关联数组 普通数组 定义 1$arr1 = array(&quot;zs&quot;,&quot;ls&quot;); 数组没有length属性， 遍历数组,使用for循环，可以得到数组的长度 php有一个函数可以获取数组的长度，count($arr); 关联数组 以键值对的方式进行存储的数组，我们叫做关联数组，123$array = array(\"key\" =&gt; \"value\");$array[\"key];//通过key可以获取值 二维数组 数组里边还有数组 输出打印 php提供了三个用来输出的方法 echo “”; 用来输出字符串的 print_r(); 用来输出数组或者对象的。 var_dump(); 这个也是用来输出数组里面的详细信息 php常见函数方法 count(); 得到数组长度 in_array(); 判断数组中是否存在某个元素，这个是用在普通数组当中的 array_key_exists(); 检测数组中是否存在某个key，这个用在关联数组中 file_get_contents(); 读取文件里边的内容，读取出来的是字符串， move_upload_file(); 移动上传的文件 表单处理 name属性 是用来提供给服务端接收数据而设置的 action属性 设置接收数据的处理程序 method属性 设置发送数据的方式 当上传文件时，必须设置 enctype=&quot;multipart/form-data&quot;,且只能使用post方式 $_GET 接收get传来的数据 $_POST 接收post传来数据 $_FILES 接收上传的文件 get和post提交 get 点击超链接，表单提交默认方式就是get，地址栏输入地址， 传递到服务端的都是参数，参数值，可以传递多个参数参数值 第一个必须是？ 参数名=参数值 可以发送多个参数到服务器 假设我要发送多个数据， 第二个参数之前添加&amp;字符 1&lt;a href=&quot;01.php?username=zs&amp;age=12&quot;&gt;&lt;/a&gt; 在php要对请求进行处理，处理我们分为三个步骤， 接收请求，接收客户端传递到服务端的数据， 如果客户端是get方式提交，用$_GET去接收数据，对应的值是一个数组，是一个关联数组。 处理请求： 接收到数据之后具体做什么，就是要使用php去操作了。 响应处理，给客户端一个响应 post提交 表单提交一般都是使用post 12345&lt;!--post 提交，我需要表单提交，设置成post--&gt; &lt;form action=&quot;02post.php&quot; method=&quot;post&quot;&gt; 用户名:&lt;input type=&quot;text&quot; name=&quot;username&quot;&gt; &lt;input type=&quot;submit&quot; value=&quot;post 提交&quot;&gt; &lt;/form&gt; 服务端处理 接收请求 1$username = $_POST[&quot;username&quot;]; 处理请求 php后端处理数据 完成响应 返回信息到客户端 文件上传前端页面 必须满足以下条件才可以上传文件 必须是表单提交 表单里面必须有 input type=”file” 必须是post方式提交 必须设置 enctype=&quot;multipart/form-data&quot;属性","tags":[]}]